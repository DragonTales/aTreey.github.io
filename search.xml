<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>Hello World</title>
      <link href="/2018/03/17/hello-world/"/>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Mac安装VirtualBox连接U盘</title>
      <link href="/2018/02/03/Mac%E5%AE%89%E8%A3%85VirtualBox%E8%BF%9E%E6%8E%A5U%E7%9B%98/"/>
      <content type="html"><![CDATA[<p>最近因为某些原因需要再Mac上安装虚拟机,所以选择了VirtualBox安装了<br>win10系统，但是需要再虚拟机的win10中访问U盘数据，遇到的问题是不能连接并且读取到U盘，错误提示不能分配USB内存。。。</p><p>网上找了好多办法都胡扯，根本没有解决…</p><p>解决方法：<br>1.升级VirtualBox到最新版<br>2.关闭当前的虚拟机中的操作系统<br>3.安装增强工具<br>4.重启VirtualBox，回到Mac桌面推出U盘即可</p><p>最重要的就是在第四步</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Block学习探究</title>
      <link href="/2018/01/19/Block%E5%AD%A6%E4%B9%A0%E6%8E%A2%E7%A9%B6/"/>
      <content type="html"><![CDATA[<h3 id="代码及结果"><a href="#代码及结果" class="headerlink" title="代码及结果"></a>代码及结果</h3><ul><li><p>普通局部变量</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)block1 &#123;</span><br><span class="line">    </span><br><span class="line">    NSInteger num = 100;</span><br><span class="line">    </span><br><span class="line">    // 定义一个block</span><br><span class="line">    dispatch_block_t block = ^ &#123;</span><br><span class="line">        NSLog(@&quot;block1 -- numer = %zd&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    num = 200;</span><br><span class="line">    </span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用__block修饰变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)block2 &#123;</span><br><span class="line">    </span><br><span class="line">    __block NSInteger num = 100;</span><br><span class="line">    </span><br><span class="line">    // 定义一个block</span><br><span class="line">    dispatch_block_t block = ^ &#123;</span><br><span class="line">        NSLog(@&quot;block2 -- numer = %zd&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    num = 200;</span><br><span class="line">    </span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>全局变量</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)block3 &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 定义一个block</span><br><span class="line">    dispatch_block_t block = ^ &#123;</span><br><span class="line">        NSLog(@&quot;block3 -- numer = %zd&quot;, blockNum);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    blockNum = 200;</span><br><span class="line">    </span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态常量</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)block4 &#123;</span><br><span class="line">    </span><br><span class="line">    static NSInteger num = 100;</span><br><span class="line">    </span><br><span class="line">    // 定义一个block</span><br><span class="line">    dispatch_block_t block = ^ &#123;</span><br><span class="line">        NSLog(@&quot;block4 -- numer = %zd&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    num = 200;</span><br><span class="line">    </span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><pre><code>2018-01-19 00:04:13.759416+0800 CycleRetain[91251:2382380] block1 -- numer = 1002018-01-19 00:04:13.760206+0800 CycleRetain[91251:2382380] block2 -- numer = 2002018-01-19 00:04:13.760473+0800 CycleRetain[91251:2382380] block3 -- numer = 2002018-01-19 00:04:13.760603+0800 CycleRetain[91251:2382380] block4 -- numer = 200</code></pre><h3 id="原理及本质"><a href="#原理及本质" class="headerlink" title="原理及本质"></a>原理及本质</h3><p>block 根据创建位置不同,共有三种:栈block,堆block,全局block</p><p>使用<strong>block本质就是为了保证栈上和堆上block内访问和修改的是同一个变量,具体的实现是将</strong>block 修饰的变动自动封装成一个结构体,让他在堆上创建<br>基于OC 底层的runtime 机制<br>block 在内部会有一个指向结构体的指针,当调用block的时候其实就是让block找出对应的指针所指的函数地址进行调用。并传入了block自己本身</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>面试中常见问题总结(二)</title>
      <link href="/2018/01/18/%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93-%E4%BA%8C/"/>
      <content type="html"><![CDATA[<h3 id="非正式协议和正式协议"><a href="#非正式协议和正式协议" class="headerlink" title="非正式协议和正式协议"></a>非正式协议和正式协议</h3><p>非正式协议：凡是给NSObject或者其子类添加的类别都是非正式协议<br>正式协议：使用 @protocol 方式声明的方法列表，有 @require 和 @optional 两种类型</p><h3 id="KVC-键值编码"><a href="#KVC-键值编码" class="headerlink" title="KVC 键值编码"></a>KVC 键值编码</h3><p> 之所以可以使用就是因为给 NObject 增加了 NSKeyValueCoding 非正式协议，NSObject 实现了协议，OC中几乎所有的对象都支持KVC，获取值的方法是不通过属性的setter、getter 方法，而是通过属性名称的key间接访问了实例变量，<strong>可以访问私有变量</strong></p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> // 官方注释</span><br><span class="line"> /* Send -setObject:forKey: to the receiver, unless the value is nil, in which case send -removeObjectForKey:.</span><br><span class="line">*/</span><br><span class="line"> - (void)setValue:(nullable ObjectType)value forKey:(NSString *)key;</span><br></pre></td></tr></table></figure></code></pre><p>如果为nil, 就会自动过滤掉, 此方法常用在字典中过滤空值</p><p>// forKeyPath: 用于符合属性,能够通过层层访问内部属性，相当于调用属性点语法, 拥有forKey 的所有功能</p><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure></code></pre><ul><li>实现原理<ul><li>利用 setValue: forKeyPath: 赋值</li></ul><ol><li>底层实现还是使用 runtime 给对象发消息，先去查找属性是否有setter方法，存在setter 就会通过 setter 方法复制，</li><li>如果没有setter方法，接着查找下是否划线的成员变量，如果有直接给赋值</li><li>如果没有下划线的成员变量，查找是否存在和key值相同的属性，如果有就直接给属性赋值</li><li>如果没有和key值相同的属性，就会执行 setValue: forUndefinedKey: 抛出一个异常程序奔溃，这也是字典转模型中需要实现这个方法的原因</li></ol></li></ul><h3 id="KVO-键值监听"><a href="#KVO-键值监听" class="headerlink" title="KVO 键值监听"></a>KVO 键值监听</h3><p>利用一个key值来找到某个属性并监听某个属性的值的变化发送给观察者，可以理解为简单的观察者模式</p><ul><li><p>KVO 使用</p><ol><li><p>为目标对象的属性添加观察者</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)testKVO &#123;</span><br><span class="line">    Person *p = [[Person alloc] init];</span><br><span class="line">    self.person = p;</span><br><span class="line">    p.name = @&quot;哈哈&quot;;</span><br><span class="line">    </span><br><span class="line">    [p addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">    </span><br><span class="line">    p.name = @&quot;我不是原来的我!你能监听到我 ？？？&quot;;</span><br><span class="line">    p.name = @&quot;看我七十二变&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ul><pre><code>2. 实现监听的方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - kvo 回调方法</span><br><span class="line">- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">    </span><br><span class="line">    NSLog(@&quot;KVO监听到的对象是 = %@, 值 = %@ , change = %@&quot;, [object class], keyPath, change);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>3. 移除观察者<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">   </span><br><span class="line">   [self removeObserver:self forKeyPath:@&quot;name&quot;];</span><br><span class="line">   NSLog(@&quot;-----控制器销毁-----&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>KVO原理</p><p>   类的属性被添加了观察者后，OC底层就会通过Runtime 动态的创建一个这个类的派生类，当前类内部的isa 指针指向了这个派生类，在派生类中重写基类被观察属性的 setter 方法，调用前后会调用 willChangeValueForKey, setValueForKey, didChangeValue 方法, 从而达到监听属性值的方法</p></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>面试中常见问题总结</title>
      <link href="/2018/01/17/%E9%9D%A2%E8%AF%95%E4%B8%AD%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<h3 id="OC-的动态性"><a href="#OC-的动态性" class="headerlink" title="OC 的动态性"></a>OC 的动态性</h3><p>OC是基于C语言的，C语言在编译阶段就会确定了调用具体的那个函数，OC它的底层是通过runtime 运行时机制来调用函数，在OC中成为消息发送，具体来说就是在编译阶段OC可以调用任何函数，即时这个函数是没有实现的，只有在运行的时候才会根据isa指针和已经注册的方法列表中找到 IMP(函数指针)真正要调用的那个函数，我们平时写的OC代码，在运行的时候也都是转换成了runtime 的方式进行的，不管是什么方法本质都是发送一个消息</p><h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><ul><li>消息机制原理: 根据方法编号列表 SEL 去映射表中查找对应方法的实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [Person allo] init];</span><br><span class="line"></span><br><span class="line">// 底层的写法</span><br><span class="line">// alloc</span><br><span class="line">Person *p = objc_msgSend(objc_getClass(&quot;Person&quot;), sel_registerName(&quot;alloc&quot;),);</span><br><span class="line"></span><br><span class="line">// init</span><br><span class="line">p = objc_msgSend(p, sel-registerName(&quot;init&quot;));</span><br><span class="line"></span><br><span class="line">// 调用对象方法本质就是：让对象发消息</span><br><span class="line">objc_msgSend(p, @selector(eat));</span><br><span class="line"></span><br><span class="line">// 调用类方法本质： 让类发消息</span><br><span class="line">objc_msgSend([Person class], @selector(run:), 20);</span><br><span class="line"></span><br><span class="line">// alloc init 也可以理解为：</span><br><span class="line"></span><br><span class="line">id objc = objc_msgSend([NSObject class], @selector(alloc));</span><br><span class="line"></span><br><span class="line">objc = objc_msgSend(objc, @selector(alloc));</span><br></pre></td></tr></table></figure><ul><li><p>runtime 消息机制调用流程</p><p>  每个对象内部都有一个isa指针，指向他自己真实的类来确定调用的是那个类的方法; 每个方法sel都有一个IMP指针（指向现实函数的指针），不管是对象方法还是类方法,都会有一个方法列表</p><ol><li>发消息时根据对象内部的isa 指针去该类所对应的方法类表中查找方法,如果没有去父类中查找</li><li>注册每个方法编号，为了以后快速查找调用</li><li>根据方法编号查找对应方法</li><li>通过isa指针和IMP指针确定最终调用的函数</li></ol></li><li><p>runtime 常见使用</p><ol><li>运行是动态添加方法</li><li>给分类添加属性，（关联属性）</li><li>字典转模型中从先遍历模型属性再从字典中查找相关值实现模型属性赋值</li><li>NSCoding 自动归档解档时对象属性过多时 <code>encodeWithCoder:</code> 和 <code>initWithCoder</code> 两个方法实现</li></ol></li></ul><h3 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h3><ul><li><p>概念</p><p>NSRunloop 是封装 CFRunloopRef 一套纯<code>C</code>的函数，</p></li><li><p>作用</p><ol><li>保持程序持续运行</li><li>处理App中各种事件，具体的有：toches事件, NSTimer 事件, Selector 事件, PerformSelector 事件，source 源等等</li><li>有事件触发时就运行，没有就休眠</li><li>渲染app 中唯一一个主线程上所有UI界面的更新</li></ol></li><li><p>使用和要点</p><ol><li>Runloop 在程序入口 main 函数中就会开启，并且开启的是主线程不会销毁除非退出程序，保证了程序一直运行并能响应事件和交互</li><li>每一条线程都是唯一对应一个Runloop</li><li>主线程不需要创建，因为在程序启动的时候就已经创建了，而子线程的需要手动创建 直接获取currentRunloop 方式（本质是使用了懒加载）</li><li><p>Runloop 对象是利用字典进行存储，因为一一对应，所有key 和value 就是线程和 他所对应的runloop</p></li><li><p>Runloop 中 NSDefaultRunLoopMode 一般情况下主线程运行的 Mode</p></li><li>UIInitializationRunLoopMode 初始化mode,通常不用</li><li>UITrackingRunLoopMode 界面跟踪, 用于scrollView 追踪触摸滑动，保证界面不受其他mode影响</li><li><p>GSEventReceiveRunLoopMode 用于接收系统事件内部 mode， 通常不用</p></li><li><p>NSRunLoopCommonModes, 并不是某种具体的 mode ，开发中使用最多，他是一个组合 mode，组合了 NSDefaultRunLoopMode和 NSRunLoopCommonModes</p></li></ol></li><li><p>Runloop 相关类</p><ol><li>Source 事件源/输入源可以理解为 激发源</li><li>Timer 基于事件触发，CADisplayLink，NSTimer 都是加到了 Runloop，受 Mode 的影响，GCD 定时器不受Runloop 影响</li><li>Observer 相当于runloop 循环中的监听器，时刻监听当前Runloop的运行状态</li><li>休眠没事情做的时候可以停下来，处于休眠状态</li></ol></li><li><p>使用场景</p><ol><li>创建NSTimer</li><li>PersforSelector方法</li><li>常驻线程：（创建后处于等待状态，有事件时响应事件）<ul><li>实现后台收集用户停留时间或者是某个按钮的点击次数，如果使用主线程会不方便，使用runloop解决</li></ul></li><li>AutoreleasePool 自动释放池</li><li>UI更新    </li></ol></li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>iOS即时通讯实现二</title>
      <link href="/2018/01/12/iOS%E5%8D%B3%E6%97%B6%E9%80%9A%E8%AE%AF%E5%AE%9E%E7%8E%B0%E4%BA%8C/"/>
      <content type="html"><![CDATA[<h2 id="实现IM通信所用协议"><a href="#实现IM通信所用协议" class="headerlink" title="实现IM通信所用协议"></a>实现IM通信所用协议</h2><p>几个协议理解</p><p>xmpp 是基于xml协议主要是易于扩展，早起用于PC时代的产品使用，流量大，耗电大交互复杂其实并不适合移动互联网时代的IM产品</p><p>MQTT 协议 适配多平台，需自己扩展好友，群组等功能</p><p>protobut 协议</p><h2 id="封装socket，自己实现"><a href="#封装socket，自己实现" class="headerlink" title="封装socket，自己实现"></a>封装socket，自己实现</h2><p>所要考虑的问题</p><ul><li><p>传输协议选择 </p><ul><li>TCP ？ 一般公司都选用（技术不是很成熟）</li><li>UDP ？QQ 腾讯增加自己的私有协议，保证数据传递的可靠性，解决了丢包，乱序的问题</li></ul></li><li><p>聊天协议选择及代表框架</p><ul><li>Socket ？ CocoaAsyncSocket </li><li>WebSockt ？是传输通讯协议，基于socket封装的一个协议 SocketRocket</li><li>MQTT ？MQTTKit 聊天协议为上层协议</li><li>protobut 协议 ？</li><li>XMPP ？XMPPFramework  聊天协议为上层协议</li><li>自定义</li></ul></li><li><p>传输数据格式</p><ul><li>Json？</li><li>XML？</li><li>ProtocolBuffer？</li></ul></li><li><p>细节相关</p><ul><li>TCP 长连接如何保持，</li><li>心跳机制</li><li>重连机制</li><li>数据安全机制</li></ul></li></ul><h3 id="CocoaAsyncSocket"><a href="#CocoaAsyncSocket" class="headerlink" title="CocoaAsyncSocket"></a>CocoaAsyncSocket</h3><ul><li>CocoaAsyncSocket 的 delegate 用来设置代理处理各个回调</li><li>delegateQueue </li><li>socketQueue 串行队列，贯穿全类并没有任何加锁，确保了socket 操作中每一步都是线程安全的</li><li><p>创建了两个读写队列（本质是数组）</p><ul><li><code>NSMutableArray *readQueue;</code> </li><li><code>NSMutableArray *writeQueue;</code></li></ul></li><li><p>全局数据缓冲: 当前socket未获取完的数据大小</p><ul><li><code>GCDAsyncSocketPreBuffer *preBuffer;</code></li></ul></li><li><p>交替延时变量: 用于进行另一服务端地址请求的延时 </p><ul><li><code>alternateAddressDelay</code></li></ul></li><li><p>connect</p></li><li><p>disconnect</p></li></ul><h2 id="数据粘包-断包"><a href="#数据粘包-断包" class="headerlink" title="数据粘包,断包"></a>数据粘包,断包</h2><ul><li><p>粘包: 如果客户端同一时间发送几条数据，而服务器只收到一大条数据</p><ul><li>原因：</li><li><p>由于传输的是数据流，经过TCP传输后，TCP使用了优化算法将多次间隔较小且数据量小的数据合并成一个大的数据块，因此三条数据合并成了一条</p><p>  <strong>TCP,UDP都可能造成粘包的原因</strong></p></li><li><p>发送端需要等缓冲区满了才发送出去，做成粘包</p></li><li>接收方不及时接收缓冲区的包，造成多个包接收</li></ul></li><li><p>断包: 因为一次发送很大的数据包，缓冲区有限，会分段发送或读取数据</p></li></ul><h2 id="CocoaAsyncSocket的封包，拆包处理"><a href="#CocoaAsyncSocket的封包，拆包处理" class="headerlink" title="CocoaAsyncSocket的封包，拆包处理"></a>CocoaAsyncSocket的封包，拆包处理</h2><ul><li><p>读取数据方法：</p><pre><code>// 有数据时调用，读取当前消息队列中的未读消息- (void)readDataWithTimeout:(NSTimeInterval)timeout tag:(long)tag</code></pre></li></ul><pre><code>**每次读取数据，每次都必须手动调用上述 readData 方法超时设置为不超时才能触发消息回调的代理****因此在第一连接时调用，再在接到消息时调用，上述方法就可以达到每次收到消息都会触发读取消息的代理**以上做法存在的问题就是没有考虑数据的拆包会有粘包情况，这时候需要用下面两个`read`方法，1. 读取指定长度、2.读取指定边界    // 读取特定长度数据时调用    - (void)readDataToLength:(NSUInteger)length withTimeout:(NSTimeInterval)timeout tag:(long)tag    // 读到特定的 data 边界时调用    - (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag**解决办法及具体思路**- 封包：给每个数据包增加一个长度或者加一个开始结束标记，表明数据的长度和类型（根据自己的项目：文本、图片、语音、红包、视频、话题、提问等等）    - 可以在数据包之后加一个结束标识符，解决了传输过程中丢包，丢失头部信息的错误包读取，读到这样的就丢弃直接读下一个数据包- 拆包：获取每个包的标记，根据标记的数据长度获取数据，最后根据类型处理数据,最后读取数据包头部的边界</code></pre><ul><li><p>利用缓冲区对数据进行读取</p><ul><li>创建读取数据包</li><li>添加到读取的队列中</li><li>从队列中取出读取任务包 </li><li><p>使用偏移量 <code>maxLength</code> 读取数据 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">- (void)readDataWithTimeout:(NSTimeInterval)timeout</span><br><span class="line">                     buffer:(NSMutableData *)buffer</span><br><span class="line">               bufferOffset:(NSUInteger)offset</span><br><span class="line">                  maxLength:(NSUInteger)length</span><br><span class="line">                        tag:(long)tag</span><br><span class="line">&#123;</span><br><span class="line">if (offset &gt; [buffer length]) &#123;</span><br><span class="line">LogWarn(@&quot;Cannot read: offset &gt; [buffer length]&quot;);</span><br><span class="line">return;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 1. 创建读取数据包</span><br><span class="line">GCDAsyncReadPacket *packet = [[GCDAsyncReadPacket alloc] initWithData:buffer</span><br><span class="line">                                                          startOffset:offset</span><br><span class="line">                                                            maxLength:length</span><br><span class="line">                                                              timeout:timeout</span><br><span class="line">                                                           readLength:0</span><br><span class="line">                                                           terminator:nil</span><br><span class="line">                                                                  tag:tag];</span><br><span class="line"></span><br><span class="line">dispatch_async(socketQueue, ^&#123; @autoreleasepool &#123;</span><br><span class="line"></span><br><span class="line">LogTrace();</span><br><span class="line"></span><br><span class="line">if ((flags &amp; kSocketStarted) &amp;&amp; !(flags &amp; kForbidReadsWrites))</span><br><span class="line">&#123;</span><br><span class="line">// 2. 向读的队列添加任务包</span><br><span class="line">[readQueue addObject:packet];</span><br><span class="line">// 3. 从队列中取出读取任务包 </span><br><span class="line">[self maybeDequeueRead];</span><br><span class="line">&#125;</span><br><span class="line">&#125;&#125;);</span><br><span class="line"></span><br><span class="line">// Do not rely on the block being run in order to release the packet,</span><br><span class="line">// as the queue might get released without the block completing.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>doReadData 方法时读取数据的核心方法</p><ul><li>如果读取对列中没有数据，就去判是否是上次已经读取了数据，但是因为没有目前还没有读取到数据的标记，这是正好设置了 read 方法中的超时时间，所以要断开socket 连接</li></ul><p><img src="https://www.jianshu.com/p/fdd3d429bdb3" alt="">                </p><ul><li>接收到数据后在 socket系统进程的数据缓冲区中<ul><li>（基于TLS的分为两种）他们在各自管道中流动，完成数据解密后又流向了全局数据缓冲区<ul><li>CFStreem </li><li>SSLPrebuffer</li></ul></li></ul></li></ul><p>处理数据逻辑： 如果当前读取包长度给明了，则直接流向currentRead，如果数据长度不清楚，那么则去判断这一次读取的长度，和currentRead可用空间长度去对比，如果长度比currentRead可用空间小，则流向currentRead，否则先用prebuffer来缓冲。</p><h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><ul><li>TCP 自带的keep-alive 使用空闲时间来发并且默认超时时间太长是2 小时，</li><li>如果应用使用了socks ，socks proxy会让tcp keep-alive失效，因为socks 协议只管转发TCP层具体的数据包，并不会转发TCP协议内的实现具体细节数据包</li><li><p>TCP 的长连接理论上是一直保持连接的，可以设置 TCP keep-alive的时间 但是实际情况下中，可能出现故障或者是因为防火墙的原因会自动把一定时间段内没有数据交互的连接给断开，心跳机制就可以维持长连接，保持活跃状态</p></li><li><p>iOS 中使用 NSTimer  <code>scheduledTimerWithTimeInterval</code> 需要在调用之前的关键位置设置 fireDate 为未来的某个时间, 然后再需要的时候开启</p></li><li>或者直接使用 <code>timerWithTimeInterval</code> 创建，然后添加到<code>runloop</code>中</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>iOS 即使通讯网络知识篇</title>
      <link href="/2018/01/10/%E7%9F%A5%E8%AF%86%E5%BD%92%E7%BA%B3%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<h2 id="网络七层协议"><a href="#网络七层协议" class="headerlink" title="网络七层协议"></a>网络七层协议</h2><p>读《图解TCP/IP》第5版以及看过的关于网络文章之后自己的理解</p><p>OSI (Open System Interconnec) 译为 开发式系统互联 七层模型从下到上一次是：物理层 -&gt; 数据链路层 —&gt; 网络层 -&gt; 传输层 -&gt; 会话层 -&gt; 表示层 -》 应用层</p><p>数据每次经过一层之后就会在数据头部增加一个首部信息</p><h5 id="物理层：网卡-网线-集线器-中继器-调制解调器"><a href="#物理层：网卡-网线-集线器-中继器-调制解调器" class="headerlink" title="物理层：网卡,网线,集线器,中继器,调制解调器"></a>物理层：网卡,网线,集线器,中继器,调制解调器</h5><ul><li>定义设备标准，如网线，光纤接口类型，将0和1转化为电信号的强和弱，达到传输<strong>比特流</strong>目的，这层数据叫比特</li></ul><h5 id="数据链路层：网桥-交换机"><a href="#数据链路层：网桥-交换机" class="headerlink" title="数据链路层：网桥,交换机"></a>数据链路层：网桥,交换机</h5><ul><li>传输的地址帧，并且有检测错误功能，保证数据可靠传输， 这层数据叫帧</li></ul><h5 id="网络层：路由器"><a href="#网络层：路由器" class="headerlink" title="网络层：路由器"></a>网络层：路由器</h5><ul><li>两个计算机通信时可能会经过多个数据链路或者通信子网，网络层将数据链路层的帧组成数据包，包中有封装好的包头，其中含有逻辑地址信息（源站点和目的站点），此层为数据包选择合适的路由和交换结点,IP协议产生，这层数据叫着数据包</li></ul><h5 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h5><ul><li>解决数据如何在网络中传输，这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的 数据包和其它在传输过程中可能发生的危险。第4层为上层提供端到端（最终用户到最终用户）的透明的、可靠的数据传输服务。所为透明的传输是指在通信过程中 传输层对上层屏蔽了通信传输系统的具体细节。传输层协议的代表包括：TCP、UDP、SPX等</li></ul><h5 id="会话层："><a href="#会话层：" class="headerlink" title="会话层："></a>会话层：</h5><ul><li>这一层也可以称为会晤层或对话层，在会话层及以上的高层次中，数据传送的单位不再另外命名，而是统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录便是由会话层完成的</li></ul><h5 id="表示层："><a href="#表示层：" class="headerlink" title="表示层："></a>表示层：</h5><ul><li>这一层主要解决拥护信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作都由表示层负责。</li></ul><h5 id="应用层：HTTP-协议"><a href="#应用层：HTTP-协议" class="headerlink" title="应用层：HTTP 协议"></a>应用层：HTTP 协议</h5><ul><li>如何包装数据</li></ul><p><strong>通常从上到下会分成四层</strong></p><p>TCP/IP 通常是指TCP/IP协议族,是一组不同协议组合在一起构成的协议族</p><ul><li>应用层：FTP 应用层协议</li><li>传输层：TCP,UDP 传输层协议,TCP 提供了一个可靠的服务</li><li>网络层：IP,ICMP 网络层协议，传输时不可靠的</li><li>链路层：以太网协议</li></ul><h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p><strong>为了解决不同计算机上进程间通信问题</strong><br>服务器在指定的端口上监听，然后生成一对儿新的socket 进行通讯，一个线程对应一个socket</p><p>英文翻译为“插座”通常称为”套接字”, 本质是对于TCP/IP的封装，有客户端 socket 和 服务端socket </p><ul><li>流式 Socket (STREAM): 是一种面向连接的socket，针对于面向连接的TCP服务应用，因为安全所以效率低</li><li>数据报式Socket (DATAGRAM): 是一种无连接的SOcket，正对于无连接的UDP服务应用，无序，不安全，需要在接收端分析重排或者要求重发，所以效率高</li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Swift加密相关</title>
      <link href="/2018/01/08/Swift%E5%8A%A0%E5%AF%86%E7%9B%B8%E5%85%B3/"/>
      <content type="html"><![CDATA[<p>最近公司项目开发中引用了 <code>Swift</code> 与 <code>OC</code> 混编, 涉及到了加密相关, 使用了第三方 <code>CryptoSwift</code>, 以下是使用过程中的简单记录</p><h3 id="CryptoSwift简介"><a href="#CryptoSwift简介" class="headerlink" title="CryptoSwift简介"></a>CryptoSwift简介</h3><ul><li>github: <a href="https://github.com/krzyzanowskim/CryptoSwift">https://github.com/krzyzanowskim/CryptoSwift</a></li><li>使用Swift 编写的加密工具包，支持多种加密算法，如：MD5、SHA1、AES-128, AES-192, AES-256… 等等</li></ul><h3 id="数组转换"><a href="#数组转换" class="headerlink" title="数组转换"></a>数组转换</h3><ul><li><p><code>data</code> 转化为字节数组</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let bytes = data.bytes</span><br><span class="line">   print(bytes)</span><br></pre></td></tr></table></figure></li><li><p>字节数组转化为 <code>data</code></p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let data = Data(bytes: [0x01, 0x02, 0x03])</span><br><span class="line">   print(data)</span><br></pre></td></tr></table></figure></li><li><p>十六进制创建字节</p><pre><code>let bytes_Hex = Array&lt;UInt8&gt;(hex: &quot;0x010203&quot;)print(bytes_Hex)</code></pre></li><li><p>字节转十六进制数</p><pre><code>let hex = bytes_Hex.toHexString()print(hex)       </code></pre></li></ul><ul><li><p>字符串生成字节数组</p><pre><code>let string2bytes = &quot;string&quot;.bytesprint(string2bytes)</code></pre></li></ul><ul><li><p>字节数组 base64</p><pre><code>let bytes1: [UInt8] = [1, 2, 3]let base64Str = bytes1.toBase64()print(base64Str!)</code></pre></li><li><p>字符串base64</p><pre><code>let str0 = &quot;test&quot;let base64Str1 = str0.bytes.toBase64()print(base64Str1!)</code></pre></li></ul><h3 id="MD5加密"><a href="#MD5加密" class="headerlink" title="MD5加密"></a>MD5加密</h3><ul><li>MD5（RFC1321）诞生于 1991 年，全称是“Message-Digest Algorithm(信息摘要算法)5”，由 MIT 的计算机安全实验室和 RSA 安全公司共同提出。</li><li><p>之前已经有 MD2、MD3 和 MD4 几种算法。MD5 克服了 MD4 的缺陷，生成 128bit 的摘要信息串，出现之后迅速成为主流算法 </p></li><li><p>字节数组MD5</p><pre><code>let str = &quot;测试test&quot;let bytes = str.bytes// 写法一let digest = bytes.md5().toHexString()print(digest)// 04f47b69e3573867a5b3c1e5edb00789// 写法二let digest1 = Digest.md5(bytes).toHexString()print(digest1)// 04f47b69e3573867a5b3c1e5edb00789</code></pre></li><li><p>Data的MD5值</p><pre><code>/// data MD5let data = Data(str.bytes)let digest3 = data.md5().toHexString()print(digest3)// 04f47b69e3573867a5b3c1e5edb00789</code></pre></li><li><p>字符串MD5</p><pre><code>///写法 一let digest4 = str.md5()print(digest4)// 04f47b69e3573867a5b3c1e5edb00789// 写法二do {    var digest4_2 = MD5()    let _ = try digest4_2.update(withBytes: &quot;测试&quot;.bytes)    let _ = try digest4_2.update(withBytes: &quot;test&quot;.bytes)    let result = try digest4_2.finish()    print(result.toHexString())    //04f47b69e3573867a5b3c1e5edb00789} catch {}    </code></pre></li></ul><h3 id="哈希算法"><a href="#哈希算法" class="headerlink" title="哈希算法"></a>哈希算法</h3><ul><li><p>字节数组SHA值</p><pre><code>let str = &quot;测试test&quot;let bytes = str.bytes//方式一let digest1 = bytes.sha1().toHexString()let digest2 = bytes.sha224().toHexString()let digest3 = bytes.sha256().toHexString()let digest4 = bytes.sha384().toHexString()let digest5 = bytes.sha512().toHexString()print(digest1, digest2, digest3, digest4 ,digest5, separator: &quot;\n&quot;)//方式二let digest6 = Digest.sha1(bytes).toHexString()let digest7 = Digest.sha224(bytes).toHexString()let digest8 = Digest.sha256(bytes).toHexString()let digest9 = Digest.sha384(bytes).toHexString()let digest10 = Digest.sha512(bytes).toHexString()print(digest6, digest7, digest8, digest9 ,digest10, separator: &quot;\n&quot;)</code></pre></li></ul><ul><li><p>Data的SHA值</p><pre><code>let data = Data(bytes: str.bytes)let digest11 = data.sha1().toHexString()let digest12 = data.sha224().toHexString()let digest13 = data.sha256().toHexString()let digest14 = data.sha384().toHexString()let digest15 = data.sha512().toHexString()print(digest11, digest12, digest13, digest14 ,digest15, separator: &quot;\n&quot;)</code></pre></li></ul><ul><li><p>字符串的SHA值</p><pre><code>let digest16 = str.sha1()let digest17 = str.sha224()let digest18 = str.sha256()let digest19 = str.sha384()let digest20 = str.sha512()print(digest16, digest17, digest18, digest19 ,digest20, separator: &quot;\n&quot;)</code></pre></li></ul><pre><code>// 方式一let digest_str = str.sha1()print(digest_str)// 方式二do {    var digest_str = SHA1()    let _ = try digest_str.update(withBytes: Array(&quot;测试&quot;.bytes))    let _ = try digest_str.update(withBytes: Array(&quot;test&quot;.bytes))    let result = try digest_str.finish()    print(result.toHexString())} catch {}</code></pre><h3 id="AES-加密"><a href="#AES-加密" class="headerlink" title="AES 加密"></a>AES 加密</h3><ul><li><p>key：公共密钥</p></li><li><p>IV： 密钥偏移量</p></li><li><p>padding：key 的补码方式</p><pre><code>key 长度不够16 字节时，需要手动填充, zeroPadding 将其补齐至 blockSize 的整数倍zeroPadding 补齐规则:- 将长度补齐至 blockSize 参数的整数倍。比如我们将 blockSize 设置为 AES.blockSize（16）- 如果长度小于 16 字节：则尾部补 0，直到满足 16 字节。- 如果长度大于等于 16 字节，小于 32 字节：则尾部补 0，直到满足 32 字节。- 如果长度大于等于 32 字节，小于 48 字节：则尾部补 0，直到满足 48 字节。 以此类推......</code></pre></li><li><p>补码方式padding, noPadding, zeroPadding, pkcs7, pkcs5, 默认使用 pkcs7,两者写法结果相同</p></li></ul><pre><code>let iv_paddding = &quot;1234567890123456&quot; // 默认是let aes_padding1 = try AES(key: key.bytes, blockMode: .CBC(iv: iv_paddding.bytes))let aes_padding2 = try AES(key: key.bytes, blockMode: .CBC(iv: iv_paddding.bytes), padding: .pkcs7)            </code></pre><ul><li><p>ECB 模式</p><pre><code>let key = &quot;hangge.com123456&quot;let str = &quot;E蜂通信&quot;print(&quot;加密前 \(str)&quot;)//MARK: 使用ECB 模式， , 使用aes128 加密let aes = try AES(key: key.bytes, blockMode: .ECB)let encrpyted = try aes.encrypt(str.bytes)print(&quot;加密后 \(encrpyted)&quot;, separator: &quot;-----&quot;) /// 解密 let decrypted = try aes.decrypt(encrpyted) print(&quot;解密后 \(decrypted)&quot;) let decryptedString = String(data: Data(decrypted), encoding: .utf8)! print(&quot;解密后字符串 \(decryptedString)&quot;)</code></pre></li></ul><ul><li><p>CBC 模式</p><pre><code>//MARK: 使用CBC 模式, 需要提供一个额外的密钥偏移量 iv    /// 写法 1 --  便捷写法    // 偏移量    let iv = &quot;1234567890123456&quot; // 默认是    // TODO: 随机密钥偏移量    let data = Data(bytes: AES.randomIV(AES.blockSize))    let random_iv = String(data: data, encoding: .utf8)</code></pre></li></ul><pre><code>/// 写法 2 --// 创建密码器let cbc_aes = try AES(key: key.bytes, blockMode: .CBC(iv: iv.bytes))let cbc_aes2 = try AES(key: key, iv: iv)let cbc_aes3 = try AES(key: key, iv: iv)let cbc_encrypted = try cbc_aes.encrypt(str.bytes)let cbc_encrypted2 = try cbc_aes2.encrypt(str.bytes)let cbc_encrypted3 = try cbc_aes3.encrypt(str.bytes)// 便捷写法解密let cbc_decrypted = try cbc_aes.decrypt(cbc_encrypted)let cbc_decryptedData = Data(cbc_decrypted)let cbc_decryptedStr = String(data: cbc_decryptedData, encoding: .utf8)print(cbc_decryptedStr)// 正常写法2 解密let cbc_decrypted2 = try cbc_aes2.decrypt(cbc_encrypted2)let cbc_decryptedStr2 = String(data: Data(cbc_decrypted2), encoding: .utf8)print(cbc_decryptedStr2)// 随机密钥偏移量解密let cbc_decrypted3 = try cbc_aes3.decrypt(cbc_encrypted3)let cbc_decryptedStr3 = String(data: Data(cbc_decrypted3), encoding: .utf8)print(cbc_decryptedStr3)</code></pre>]]></content>
      
      
        <tags>
            
            <tag> AES, Base64, MD5 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Mac 安装MySQL</title>
      <link href="/2017/12/14/Mac-%E5%AE%89%E8%A3%85MySQL/"/>
      <content type="html"><![CDATA[<p>搭建 <code>XMPP</code> 即使通讯</p><h2 id="安装MySQL数据库"><a href="#安装MySQL数据库" class="headerlink" title="安装MySQL数据库"></a>安装MySQL数据库</h2><ul><li><p>安装MySQL 数据库    </p><ul><li><p><a href="https://www.mysql.com/" target="_blank" rel="noopener">官网</a> 下载安装包</p><p><strong>特别强调：不要一直<code>下一步</code>最后的时候会有个弹窗提示你生成root的临时密码，记录一下</strong></p></li></ul></li><li><p>安装数据库管理工具 <code>MySQLWorkbench</code></p><p> 官网安装包下载安装</p></li><li><p>修改数据库 root 密码，</p><p>  打开<code>MySQLWorkbench</code> 随便打开一个SQL 输入安装时记录的密码，确认后提示你修改密码，</p></li><li><p>如果为记住安装时密码，参考下面链接修改</p><p>  <a href="https://www.cnblogs.com/sunny3096/p/7954129.html" target="_blank" rel="noopener"></a> </p></li></ul><h2 id="安装-openfire"><a href="#安装-openfire" class="headerlink" title="安装 openfire"></a>安装 openfire</h2><ul><li><p><a href="https://www.igniterealtime.org/downloads/index.jsp" target="_blank" rel="noopener">官网</a> 下载安装包安装</p></li><li><p>安装后需重启系统偏好设置</p></li><li>如果出现右边的管理员配置按钮不能点击，请使用 <code>brew</code> 安装 或者更新 <code>Java</code> 环境，<code>openfire</code> 需要 <code>Java</code> 环境  </li></ul>]]></content>
      
      
    </entry>
    
    <entry>
      <title>本地已有项目添加Pod</title>
      <link href="/2017/12/02/%E6%9C%AC%E5%9C%B0%E5%B7%B2%E6%9C%89%E9%A1%B9%E7%9B%AE%E6%B7%BB%E5%8A%A0Pod/"/>
      <content type="html"><![CDATA[<p>上一篇中主要记录了如何使用 <code>pod</code> 工具自动创建 <code>pod</code> 库并且生成一个测试Demo，这边主要记录给已有的项目添加 <code>pod</code></p><h2 id="创建-podsepc-文件"><a href="#创建-podsepc-文件" class="headerlink" title="创建 .podsepc 文件"></a>创建 .podsepc 文件</h2><ul><li><p><code>cd</code> 到已有项目的根目录执行命令： <code>pod spec create [ProjectName].podspec</code></p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec create EmotionKeyboard.podspec</span><br></pre></td></tr></table></figure></li></ul><h2 id="修改编辑-podsepc-文件"><a href="#修改编辑-podsepc-文件" class="headerlink" title="修改编辑 .podsepc 文件"></a>修改编辑 <code>.podsepc</code> 文件</h2><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">s.name         = &quot;EmotionKeyboard&quot;</span><br><span class="line">  s.version      = &quot;0.0.1&quot;</span><br><span class="line">  s.summary      = &quot;A  Emotional Keyboard.&quot;</span><br><span class="line">  </span><br><span class="line">  # 此处的格式不能修改</span><br><span class="line">  s.description  = &lt;&lt;-DESC</span><br><span class="line"></span><br><span class="line">Swift Emotional Keyboard</span><br><span class="line">                   DESC</span><br><span class="line"></span><br><span class="line">s.homepage     = &quot;https://github.com/aTreey/EmotionKeyboard&quot;</span><br><span class="line"></span><br><span class="line"># 两种写法，使用下面第二种  </span><br><span class="line"># s.license      = &quot;MIT (example)&quot;</span><br><span class="line">s.license      = &#123; :type =&gt; &quot;MIT&quot;, :file =&gt; &quot;LICENSE&quot; &#125;</span><br><span class="line"></span><br><span class="line">s.author             = &#123; &quot;aTree&quot; =&gt; &quot;480814177@qq.com&quot; &#125;</span><br><span class="line"></span><br><span class="line">s.platform     = :ios, &quot;8.0&quot;</span><br><span class="line"></span><br><span class="line">s.source       = &#123; :git =&gt; &quot;https://github.com/aTreey/EmotionKeyboard.git&quot;, :tag =&gt; &quot;#&#123;s.version&#125;&quot; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 从 .podspec 同级别的目录下起匹配 </span><br><span class="line">s.source_files  = &quot;EmotionKeyboard&quot;, &quot;EmotionKeyboard/Classes/**/*.&#123;h,m&#125;&quot;</span><br><span class="line"></span><br><span class="line"># 设置自己项目中依赖的系统库</span><br><span class="line">s.framework  = &quot;UIKit&quot;</span><br><span class="line">  </span><br><span class="line">``` </span><br><span class="line"></span><br><span class="line">## 调整文件的目录结构</span><br><span class="line"></span><br><span class="line">- 在项目根目录下新建一个放组件代码的文件夹</span><br><span class="line">- 如果项目中包含 `bundle` 文件, 需要在组件文件夹下新建一个 `Assets` 文件夹，用来存放组件中的资源</span><br><span class="line"></span><br><span class="line">最终结果如下:</span><br><span class="line"></span><br><span class="line">![](https://ws1.sinaimg.cn/large/a1641e1bly1fm2jl7ykslj21gc0o80xt.jpg))</span><br><span class="line"></span><br><span class="line">- 创建并添加必要文件</span><br><span class="line"></span><br><span class="line">- `LICENSE` 文件: 开源许可文件, 如果创建项目的时候选择了开源许可就可以自动生成忽略此步骤,如果没有直接拷贝一份其他的工程中的即可</span><br><span class="line">- `README.md` 文件: 主要用来说明你开源库的信息及使用方法</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 验证本地 `.podspec` 文件</span><br><span class="line"></span><br><span class="line">- 错误1: `.podspec `中的文件路径设置错误</span><br><span class="line"></span><br><span class="line">![](https://ws1.sinaimg.cn/large/a1641e1bly1fm2jlboq82j20v807ejug.jpg)</span><br><span class="line"></span><br><span class="line">- 错误2: bundle 文件资源路径错误</span><br><span class="line"></span><br><span class="line">![](https://ws1.sinaimg.cn/large/a1641e1bly1fm2jl4shnnj20zq0cwgqf.jpg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">- 本地验证结果</span><br><span class="line"></span><br><span class="line"> - **EmotionKeyboard passed validation.** 本地验证验证通过</span><br><span class="line"></span><br><span class="line">## 网络验证 `.podspec` 文件 </span><br><span class="line"></span><br><span class="line">- 给 `master` 分支打上 `.podspec` 文件中对应的 `tag` 标签, 提交推送, </span><br><span class="line">- 执行命令</span><br></pre></td></tr></table></figure>pod spec lint<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 网络验证结果</span><br></pre></td></tr></table></figure>EmotionKeyboard.podspec passed validation.```</code></pre><p><strong>本文参考</strong></p><p><a href="http://blog.xianqu.org/2015/08/pod-resources/" target="_blank" rel="noopener">给 Pod 添加资源文件</a></p><p><a href="http://swift.gg/2016/12/15/cocoapods-making-guide/" target="_blank" rel="noopener">基于 Swift 创建 CocoaPods 完全指南</a></p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>CocoaPods制作私有pod</title>
      <link href="/2017/11/29/CocoaPods%E5%88%B6%E4%BD%9C%E7%A7%81%E6%9C%89pod/"/>
      <content type="html"><![CDATA[<h2 id="CocoaPods原理"><a href="#CocoaPods原理" class="headerlink" title="CocoaPods原理"></a>CocoaPods原理</h2><p><strong>本文主要记录制作自己的pod库过程</strong></p><p>CocoaPods 是自动化工具，主要用来管理一些开源的第三方框架，或者是制作自己的私有库,开源库,也可以使用它讲自己的项目组件化。</p><p>具体可以参考：</p><ol><li><a href="https://juejin.im/post/58730a25a22b9d0058971144" target="_blank" rel="noopener">细聊 Cocoapods 与 Xcode 工程配置</a></li><li><a href="https://juejin.im/post/59f2c7eaf265da432c2318e5" target="_blank" rel="noopener">你真的会用 CocoaPods 吗?</a></li></ol><h2 id="CocoaPods-安装"><a href="#CocoaPods-安装" class="headerlink" title="CocoaPods 安装"></a>CocoaPods 安装</h2><p><a href="http://www.pluto-y.com/cocoapods-getting-stared/" target="_blank" rel="noopener">安装教程</a></p><h2 id="创建私有索引仓库"><a href="#创建私有索引仓库" class="headerlink" title="创建私有索引仓库"></a>创建私有索引仓库</h2><p>每次使用第三方开源库的时候只需要在 <code>Podfile</code> 文件中指定所用的库然后 <code>Pod install</code> ，这是因为安装pod的时候 <code>pod setup</code> 从<a href="https://github.com/CocoaPods/Specs">远程仓库</a>（索引库） clone到了本地,此仓库中存放了所有支持pod框架的描述信息(包括每个库的各个版本)</p><p>文件目录：</p><pre><code>~/.cocoapods/repos/master</code></pre><ul><li><p>在 <a href="https://gitee.com/" target="_blank" rel="noopener">码云</a> 或者 <a href="">coding</a> 上创建一个私有仓库</p></li><li><p>添加私有库到CocoaPods</p><ul><li><p>格式 <code>pod repo add [repoName] (URL)</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">pod repo add PrivateSpec https://gitee.com/aapenga/PrivateSpec.git </span><br><span class="line">```</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">## 创建本地私有库</span><br><span class="line"></span><br><span class="line"> - `cd` 到任意一个文件夹下, 执行 `pod lib create [项目名]`</span><br><span class="line"></span><br><span class="line">``` </span><br><span class="line"> pod lib create PPExcelView</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li>将文件放入到生成的 Demo 文件夹 的 <code>Classes</code> 文件目录下</li><li><p><code>cd</code> 到 <code>Example</code> 下(含有 <code>Podfile</code> 文件) 执行</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod install</span><br></pre></td></tr></table></figure><p>或者</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod update</span><br></pre></td></tr></table></figure></li></ul><p> 此时添加的文件出现在 <code>Dome</code> Pod 的 <code>Development Pods</code> 目录中</p><ul><li><p>从本地验证 pod 是否通过</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint</span><br></pre></td></tr></table></figure><p>  如果有警告，可以使用 <code>--private</code> 或者 <code>--allow-warnings</code> 忽略</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pod lib lint --allow-warnings</span><br><span class="line">pod lib lint --private</span><br></pre></td></tr></table></figure><p> <strong>出现     <code>PPExcelView passed validation.</code> 为通过</strong></p></li><li><p>从远程仓库验证 pod </p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pod spec lint</span><br></pre></td></tr></table></figure><p>  <strong>出现     <code>PPExcelView.podspec passed validation</code> 为通过</strong></p></li></ul><h2 id="推送-podspec-文件到私有仓库"><a href="#推送-podspec-文件到私有仓库" class="headerlink" title="推送 .podspec 文件到私有仓库"></a>推送 <code>.podspec</code> 文件到私有仓库</h2><p><code>cd</code> 到 <code>.podspec</code> 所在的文件下</p><pre><code>pod repo push MyGitSpec PPExcelView.podspec</code></pre>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Alamofire源码学习总结</title>
      <link href="/2017/04/10/Alamofire%E6%BA%90%E7%A0%81%E5%AD%A6%E4%B9%A0/"/>
      <content type="html"><![CDATA[<h4 id="网络请求时Path和Query-之间是用-‘？’-号隔开，后边是传给服务器的参数，GET请求Query是放在URL之后，POST请求是放在Body中"><a href="#网络请求时Path和Query-之间是用-‘？’-号隔开，后边是传给服务器的参数，GET请求Query是放在URL之后，POST请求是放在Body中" class="headerlink" title="网络请求时Path和Query 之间是用 ‘？’ 号隔开，后边是传给服务器的参数，GET请求Query是放在URL之后，POST请求是放在Body中"></a>网络请求时Path和Query 之间是用 ‘？’ 号隔开，后边是传给服务器的参数，GET请求Query是放在URL之后，POST请求是放在Body中</h4><ul><li><p>如果参数是一个 key-value 形式，Query 格式为：key=value</p></li><li><p>如果参数是一个数组 key = [value1, value2, value3 ….], </p></li><li><p>Query 格式为 key[]=value1&amp;key[]=value2&amp;key[]=value3</p></li><li><p>如果参数是一个字典</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key = [“subKey1”:”value1”, “subKey2”:”value2”, “subKey3”:”value3”….],</span><br></pre></td></tr></table></figure><ul><li>Query 的格式为 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key[subKey1]=value1&amp;key[subKey2]=value2&amp;key[subKey3]=value3</span><br></pre></td></tr></table></figure><ul><li>Alamfire中的编码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">private func query(_ parameters: [String: Any]) -&gt; String &#123;</span><br><span class="line">        var components: [(String, String)] = []</span><br><span class="line">        for key in parameters.keys.sorted(by: &lt;) &#123;</span><br><span class="line">            let value = parameters[key]!</span><br><span class="line">            components += queryComponents(fromKey: key, value: value)</span><br><span class="line">        &#125;</span><br><span class="line">        return components.map &#123; &quot;\($0)=\($1)&quot; &#125;.joined(separator: &quot;&amp;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">public func queryComponents(fromKey key: String, value: Any) -&gt; [(String, String)] &#123;</span><br><span class="line">        var components: [(String, String)] = [] // 元祖数组</span><br><span class="line">        if let dictionary = value as? [String: Any] &#123; // value 为字典，key[subKey]=value 形式</span><br><span class="line">            for (nestedKey, value) in dictionary &#123;</span><br><span class="line">                components += queryComponents(fromKey: &quot;\(key)[\(nestedKey)]&quot;, value: value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if let array = value as? [Any] &#123; // value为数组， key[]=value 形式 </span><br><span class="line">            for value in array &#123;</span><br><span class="line">                components += queryComponents(fromKey: &quot;\(key)[]&quot;, value: value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if let value = value as? NSNumber &#123; // value为 NSNumber</span><br><span class="line">            if value.isBool &#123;</span><br><span class="line">                components.append((escape(key), escape((value.boolValue ? &quot;1&quot; : &quot;0&quot;))))</span><br><span class="line">            &#125; else &#123;</span><br><span class="line">                components.append((escape(key), escape(&quot;\(value)&quot;)))</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; else if let bool = value as? Bool &#123; // value 为 Bool </span><br><span class="line">            components.append((escape(key), escape((bool ? &quot;1&quot; : &quot;0&quot;))))</span><br><span class="line">        &#125; else &#123; // value 为字符串时 直接转义</span><br><span class="line">            components.append((escape(key), escape(&quot;\(value)&quot;)))</span><br><span class="line">        &#125;</span><br><span class="line">        return components</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Alamofire </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>知识点总结</title>
      <link href="/2017/03/25/%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<p>开发中的知识点总结</p><p>textField</p><p>使用textField自定义搜索框，textField及leftView等属性<br>使用leftView 时需要设置model为始终显示<br>可以设置leftView的frame 调整图片大小<br>IBInsepectable IBDesignable 的使用</p><p>给属性检查器面板中添加属性设置选项<br>IBDesignalbe 实时显示UI控件，需要讲对应的xib和对应类绑定</p><p>增加分类</p><p>新建一个swift 文件，</p><p>使用extension，重写 get set方法<br>使用newValue 时需要判断,注意返回值的类型是否匹配<br>试图切换</p><p>一个控制器中加载不同视图，可以在loadView 方法中自定义根视图</p><p>loadView 使用注意事项<br>如果实现loadView 未调用 super loadView ，sb／xib实效<br>loadView调用时，如果根视图是nil（本质是未调用super loadView），会自动调用loadView 方法初始化根视图，形成递归调用<br>判断当前登陆标识的状态确定是调用 super loadView 还是 把创建自定义的根视图赋值给 view<br>VFL 的使用</p><p>使用之前需要先 关闭frame 的布局才能手动的添加约束 translatesAutoresizingMaskIntoConstraints = false<br>基本动画使用</p>]]></content>
      
      
    </entry>
    
    <entry>
      <title>Swift3.0学习(三)</title>
      <link href="/2017/03/08/Swift3.0%E5%AD%A6%E4%B9%A0(%E4%B8%89)/"/>
      <content type="html"><![CDATA[<p>面向对象–必选属性</p><p>构造函数时是分段构造，先构造子类，给’必选属性’设置初始值，然后再构造父类，<br>定义全局变量（属性）时，需要在构造函数中设置初始化变量值<br>super.init()是一个类构造结束<br>重写： override 函数重写（覆盖），如果在重写的方法中 没有super, 父类相关的一些操作就不会被执行<br>重载：函数名相同, 参数的类型 或者参数的个数不同 就形成了函数的重载<br>注意：重载构造函数,并且父类默认的构造函数 init()不重写， 父类默认的构造函数就不能够被访问,不能够确保必选属性设置初始值，只能调用重载的构造函数<br>面向对象–可选属性</p><p>使用KVC给对象设置值<br>注意: 在swift中使用KVC 基本数据类型不能声明为可选项,必须设置为必选项给定初始值</p><p>KVC实现的流程<br>遍历字典的键值 给对象发送 setValue: forKey消息<br>如果key 对象的属性不存在就将消息转发给 setVale: forUndefinedKey:<br>如果存在就直接设置值<br>注意:setVale: forUndefinedKey: 默认抛出异常 不能够super，如果super 相当于没有实现此方法</p><p>面向对象–便利构造函数</p><p>作用：方便快捷的创建对象<br>场景：<br>可检查参数是否正确来实例化<br>实例化控件<br>特点<br>必须以self来调用构造函数<br>指定的构造函数不能被重写，也不能被super调用<br>便利构造函数可被子类继承<br>可以构造失败，返回nil<br>面向对象 – 描述信息</p><p>重写 description 方法，返回值是string类型<br>使用kvc讲对象属性转换为字典<br>将字典转化为string类型</p><pre><code>override var description: String {        let keys = [&quot;name&quot;,&quot;age&quot;,&quot;number&quot;,&quot;sex&quot;]        // 对象转为字典        let dict = self.dictionaryWithValuesForKeys(keys)        // 每个对象都有描述属性        return dict.description    }</code></pre><p>面向对象 – 存储属性</p><p>面向对象 – 计算属性(readOnly)</p><p>只有getter，没有setter<br>只能取值不能赋值<br>每次调用都会被执行，消耗cpu<br>不占内存空间，依赖其他的属性来计算<br>面向对象 – didset 属性设置监察器</p><p>能获取 oldValue 和 newValue 的值<br>通常用来重写setter方法，实现视图绑定模型<br>在一个属性的didset中计算其他属性</p><p>缺点：消耗内存，被计算的属性占内存<br>优点：减少了cpu消耗<br>懒加载</p>]]></content>
      
      
        <tags>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift3.0学习(二)</title>
      <link href="/2017/03/05/Swift3.0%E5%AD%A6%E4%B9%A0(%E4%BA%8C)/"/>
      <content type="html"><![CDATA[<p>字符串</p><p>字符串遍历<br>字符串字节长度<br>字符串长度</p><p>let string = “我是switf,语言”</p><p>   // 字符串遍历<br>   for s in string.characters {<br>       print(s)<br>   }</p><p>   // 字符串的长度<br>   let length = string.characters.count;<br>   print(length)</p><p>   // 字符串字节长度 汉字对应3个字节，英文是1个字节<br>   let characterLength = string.lengthOfBytesUsingEncoding(NSUTF8StringEncoding)<br>   print(characterLength)</p><p>字符串拼接</p><pre><code>let str1 = &quot;你好&quot;   let str2 = &quot;不好&quot;   let a = 20   // 第一种拼接   print(&quot;\(str1)\(str2)\(a)&quot;)   // 第二种拼接   let str = str1 + str2   let strA = str1 + String(a)   print(str)   print(strA)</code></pre><p>截取子串 as 的使用</p><pre><code>let subString = str1.substringToIndex(&quot;小程生生世世&quot;.endIndex);   print(subString)   let subStr = str1.substringFromIndex(&quot;听说&quot;.startIndex)   print(subStr)   let range = str1.rangeOfString(&quot;小程序&quot;)   let subStr1 = str1.substringWithRange(range!)   print(subStr1)   // 截取到某一个位置   let subStr2 = str1.substringFromIndex(str1.endIndex.advancedBy(-2))   print(subStr2)   // 限制截取几个字符   let subStr3 = str1.substringToIndex(str1.startIndex.advancedBy(5, limit: str1.characters.endIndex))   print(subStr3)String 和 NSString 之间的 使用 as 无缝转换let helloString = &quot;我们一起飞&quot;(helloString as NSString).substringWithRange(NSMakeRange(2, 3))数组</code></pre><p>可以放不同类型的元素<br>let不可变数组,var可变数组</p><pre><code>// 初始化一个空数组 [String]声明是一个装有字符串的数组类型   var emptyArray: [String] = [String]()// 可变数组   var array = [&quot;哈哈&quot;,&quot;呵呵&quot;,&quot;嘿嘿&quot;]   array.append(&quot;咯咯&quot;)   print(&quot;array = \(array)&quot;)   // 不可变数组   let array2 = [&quot;可可&quot;,&quot;噗噗&quot;]   // 数组拼接   let arr = array + array2   print(&quot;arr = \(arr)&quot;)   array += array2   print(&quot;array = \(array)&quot;)</code></pre><p>数组遍历</p><pre><code>// 1.    for i in 0 ..&lt; tempArray.count {       print(tempArray[i])   }   // 2.    for obj in tempArray {       print(&quot;第二种方法:\(obj)&quot;)   }   // 3. 快速便利   for (index,value) in tempArray.enumerate() {       print(&quot;index = \(index), value = \(value)&quot;)   }</code></pre><p>字典和OC类似</p><p>函数调用</p><p>必须在函数声明的下面调用内部函数</p><p>可以定义函数的外部参数和内部参数</p><p>可以在参数前面加上 ‘# ’ 表明函数的外部参数和内部参数名称一样 swift3.0 以后废弃</p><p>无参无返回值<br>三种写法</p><pre><code>func demo9() -&gt; Void {       print(&quot;无参无返回值第一种写法&quot;)   }   func demo_9() -&gt; () {       print(&quot;无参无返回值第二种写法&quot;)   }   func demo_99() {       print(&quot;无参无返回值第三种写法&quot;)   }</code></pre><p>有参有返回值</p><pre><code>func demo10(width a: Int, height b: Int) -&gt; Int {   return a * b</code></pre><p>   }</p><p>闭包</p><p>和OC中block类似，<br>和在函数中调用一个内部函数原理相同<br>可当作参数传递<br>在需要时执行闭包实现回调</p><pre><code>// 定义闭包let closure = {() -&gt; () in       print(&quot;闭包实现&quot;)   }   // 执行闭包   closure()</code></pre><p>注意循环引用</p><p>只有两个对象相互强引用或者三个对象相互强引用形成闭环时才会形成循环引用</p><p>weak 和 unsafe_unretained的区别</p><p>__weak iOS5.0 推出，当对象被系统回收时，对象的地址会自动指向nil</p><p>____unsafe_unretained iOS4.0 推出，当对象被系统回收时，对象的地址不会自动指向nil,会造成野指针访问<br>解决办法：(官方推荐)weak - strong -dance 解决循环引用，AFNetworking中</p><p>尾随闭包</p><p>函数的最后一个参数时闭包的时候，函数的参数 ‘()’可以提前关闭，闭包写在 ‘（）’后面，当作尾随闭包来使用</p><p>swift 和 OC 区别</p><p>swift 和 OC语法的快速的对比</p><p>XXX.init(xxx) ==&gt; XXX.(xxx)<br>selector 类型 ==&gt; ‘函数名’<br>对象方法的调用 是 ‘.’ self是可以省略的<br>枚举 枚举名 + 枚举值的名 =&gt; .枚举值的名<br>常量 和变量</p><p>let 声明常量 var 声明变量<br>变量/常量的类型是自动推到的<br>不同类型之间不能够直接运算 需要手动转换数据类型<br>可选项<br>‘?’ 表示表示可选项 可能有值 可能为 nil<br>可选项会自动带上 Optional 字样<br>可选项不能够直接参与运算 需要强制解包<br>‘!’ 表示强制解包 获取可选项中具体的值<br>‘??’ 快速判断可选项是否为nil 如果为 nil 就去取 ‘??’后面的默认值<br>控制流<br>if 没有非零即真的概念 必须制定明确的条件<br>if let 快速赋值 并且判断赋值对象是否为 nil 如果不为nil 就进入分之执行相关逻辑代码<br>guard let 作用和 if let 相反 好处: 可以减少一层分支嵌套<br>where 多重判断 注意 和 &amp;&amp; || 不一样的<br>循环</p><p>for in<br>0..&lt;10<br>0…10<br>字符串</p><p>更加轻量级 更加高效 是 结构体<br>支持快速遍历<br>长度<br>拼接<br>截取 as<br>集合 let 声明不可变的集合 var 声明可变的集合</p><p>声明 []<br>声明一个 空的集合<br>增删改查<br>合并<br>遍历<br>函数</p><p>func 函数名称(外部参数1 内部参数1: 类型, 外部参数2 内部参数2: 类型) -&gt; Int {执行的代码}<br>函数没有返回值的三种方式<br>函数内部函数<br>闭包 () -&gt; () 没有参数没有返回值的闭包类型</p><p>提前准备好的一段可以执行代码块<br>可以当做参数传递<br>在需要的时候执行闭包产生回调的效果<br>在闭包中使用self 需要考虑循环引用<br>函数是一种特殊的闭包</p><p>block 的循环引用的解除<br><strong>weak 和 weak关键字作用类似 当属性对象被回收是 会自动指向nil<br>_</strong>unsafeunretained 和 assgin关键字作用类似 当属性对象被回收是 不会自动指向nil, 会造成野指针访问 weak -strong - dance</p>]]></content>
      
      
        <tags>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Swift 3.0 学习</title>
      <link href="/2017/03/01/Swift3.0%E5%AD%A6%E4%B9%A0(%E4%B8%80)/"/>
      <content type="html"><![CDATA[<h2 id="和OC区别"><a href="#和OC区别" class="headerlink" title="和OC区别"></a>和OC区别</h2><ul><li>没有了.h 和 .m 文件，没有main.m 文件</li><li>程序入口发生变化 在appdelegate中的 @UIApplicationMain</li><li>每行代码可以不写 ‘;’</li><li>self可以不写，建议不写self，因为闭包中必须要写</li><li>真假表示只有 true／ false，没有非0即真的概念</li><li>类型自动推到</li></ul><h2 id="类型自动推到"><a href="#类型自动推到" class="headerlink" title="类型自动推到"></a>类型自动推到</h2><h2 id="提前指定类型"><a href="#提前指定类型" class="headerlink" title="提前指定类型"></a>提前指定类型</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let float :Double = 9.6 </span><br><span class="line">print(float)</span><br></pre></td></tr></table></figure><h2 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h2><ul><li>let 声明常量，有且只有一次赋值机会</li><li>var 声明变量</li><li>尽量选择使用let如需修改值再使用var 系统会报警告</li></ul><h2 id="可选项"><a href="#可选项" class="headerlink" title="可选项"></a>可选项</h2><ul><li>Optional: 表示一个常量或者是变量可能有值可能为nil，在打印的时候会带有Optional字样</li><li>? 表示是一个可选项</li><li>可选项不能参与运算</li><li><p>! 表示可选项中一定要有值，可以强制解包,解包时如果没有值会boom</p></li><li><p>?? 合并空选项 快速判断可选项是否为nil, 如果为nil取后面的默认值，在基本数据类型和字符串使用较多</p></li></ul><h2 id="条件分支"><a href="#条件分支" class="headerlink" title="条件分支"></a>条件分支</h2><ul><li>if let</li></ul><p>快速赋值，判断赋值对象是否为nil，如果不为nil，就赋值进入分支<br>生成request是url是一个可选项，需要强制解包或者合并空选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let urlString = &quot;http://www.baidu.com&quot;</span><br><span class="line">let url = NSURL(string: urlString)</span><br><span class="line">let request = NSURLRequest(URL: url!)</span><br><span class="line">print(request)</span><br></pre></td></tr></table></figure><ul><li>以上代码使用if let实现</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if let u = NSURL(string: urlString) &#123;</span><br><span class="line">    let request = NSURLRequest(URL: u)</span><br><span class="line">    print(request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>where条件语句配合多重判断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">if url != nil  &#123;</span><br><span class="line">    if url?.host == &quot;www.baidu.com&quot; &#123;</span><br><span class="line">        let request = NSURLRequest(URL: url!)</span><br><span class="line">        print(request)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>使用if let</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if let u = url where u.host == &quot;www.baidu.com&quot; &#123;</span><br><span class="line">    let request = NSURLRequest(URL: u)</span><br><span class="line">    print(request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>多重判断</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">if let u = url, s = string &#123;</span><br><span class="line">    let request = NSURLRequest(URL: u)</span><br><span class="line">    print(request)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>guard let 和 if let 相反如果为nil，可以直接返回</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let urlString  = &quot;http://www.baidi.com&quot;</span><br><span class="line">let url = NSURL(string: urlString)</span><br><span class="line">guard let u = url else &#123; return &#125;</span><br><span class="line">    </span><br><span class="line">//程序走到这个地方就表示 u 一定有值</span><br><span class="line">let request = NSURLRequest(URL: u)</span><br><span class="line">print(request)</span><br></pre></td></tr></table></figure><ul><li><p>swith语句</p><ul><li>swift语句中可以case任意类型，</li><li>在OC中只能case整数</li><li>不需要写break,会自动跳出，</li><li>如果需要实现case穿透，需要加入fallthrough语句</li><li>case语句中临时变量不需要写‘{ }’</li><li>可同时case多个值    </li><li>每句case语句中至少要有一行可执行的代码</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">let string = &quot;string1&quot;</span><br><span class="line">       switch string &#123;</span><br><span class="line">       case &quot;string&quot;, &quot;string1&quot;:</span><br><span class="line">           let str = &quot;stringOne&quot;</span><br><span class="line">           print(str)</span><br><span class="line">           </span><br><span class="line">       case &quot;string2&quot;:</span><br><span class="line">           let str = &quot;stringTWO&quot;</span><br><span class="line">           print(str)</span><br><span class="line">           </span><br><span class="line">       case &quot;string3&quot;:</span><br><span class="line">           print(string)</span><br><span class="line">           </span><br><span class="line">       case &quot;string4&quot;:</span><br><span class="line">           print(string)</span><br><span class="line">       default:</span><br><span class="line">           print(&quot;empty&quot;)</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure><ul><li>switch 中同样能够赋值和使用 where 子句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">let point = CGPoint(x: 10, y: 10)</span><br><span class="line">switch point &#123;</span><br><span class="line">case let p where p.x == 0 &amp;&amp; p.y == 0:</span><br><span class="line">    print(&quot;中心点&quot;)</span><br><span class="line">case let p where p.x == 0:</span><br><span class="line">    print(&quot;Y轴&quot;)</span><br><span class="line">case let p where p.y == 0:</span><br><span class="line">    print(&quot;X轴&quot;)</span><br><span class="line">case let p where abs(p.x) == abs(p.y):</span><br><span class="line">    print(&quot;对角线&quot;)</span><br><span class="line">default:</span><br><span class="line">    print(&quot;其他&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>循环语句</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for i in 0 ..&lt; 10 &#123; // 不包含10  循环范围中两边的值格式必须一直（空格问题）</span><br><span class="line">       print(i)</span><br><span class="line">   &#125;</span><br><span class="line">       </span><br><span class="line">for _ in 0...5 &#123;// 包含5  _ 表示忽略，不关心，只占位</span><br><span class="line">    print(&quot;循环语句&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OC和JS交互</title>
      <link href="/2017/02/20/OC%E4%B8%8Ejs%E4%BA%A4%E4%BA%92%E5%AD%A6%E4%B9%A0/"/>
      <content type="html"><![CDATA[<h3 id="WebView相关属性"><a href="#WebView相关属性" class="headerlink" title="WebView相关属性"></a>WebView相关属性</h3><p>autoResizingMask 是UIView的属性,作用是实现子控件相对于父控件的自动布局</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">autoResizingMask 是UIViewAutoresizing 默认是 UIViewAutoresizingNone</span><br><span class="line"></span><br><span class="line">UIViewAutoresizingNone = 0,</span><br><span class="line">UIViewAutoresizingFlexibleLeftMargin = 1 &lt;&lt; 0,</span><br><span class="line">UIViewAutoresizingFlexibleWidth = 1 &lt;&lt; 1,</span><br><span class="line">UIViewAutoresizingFlexibleRightMargin = 1 &lt;&lt; 2,</span><br><span class="line">UIViewAutoresizingFlexibleTopMargin = 1 &lt;&lt; 3,</span><br><span class="line">UIViewAutoresizingFlexibleHeight = 1 &lt;&lt; 4,</span><br><span class="line">UIViewAutoresizingFlexibleBottomMargin = 1 &lt;&lt; 5</span><br></pre></td></tr></table></figure><p>各属性解释：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">UIViewAutoresizingNone</span><br><span class="line">不会随父视图的改变而改变</span><br><span class="line"></span><br><span class="line">UIViewAutoresizingFlexibleLeftMargin</span><br><span class="line"></span><br><span class="line">自动调整view与父视图左边距，以保证右边距不变</span><br><span class="line"></span><br><span class="line">UIViewAutoresizingFlexibleWidth</span><br><span class="line">自动调整view的宽度，保证左边距和右边距不变</span><br><span class="line"></span><br><span class="line">UIViewAutoresizingFlexibleRightMargin</span><br><span class="line">自动调整view与父视图右边距，以保证左边距不变</span><br><span class="line"></span><br><span class="line">UIViewAutoresizingFlexibleTopMargin</span><br><span class="line">自动调整view与父视图上边距，以保证下边距不变</span><br><span class="line"></span><br><span class="line">UIViewAutoresizingFlexibleHeight</span><br><span class="line">自动调整view的高度，以保证上边距和下边距不变</span><br><span class="line"></span><br><span class="line">UIViewAutoresizingFlexibleBottomMargin</span><br><span class="line">自动调整view与父视图的下边距，以保证上边距不变</span><br></pre></td></tr></table></figure><h3 id="OC-调用js"><a href="#OC-调用js" class="headerlink" title="OC 调用js"></a>OC 调用js</h3><p><code>webViewDidFinishLoad:(UIWebView *)webView</code>方法中</p><ul><li>删除增加结点</li><li>添加点击事件</li></ul><h3 id="js调用OC"><a href="#js调用OC" class="headerlink" title="js调用OC"></a>js调用OC</h3><p><code>webView:(UIWebview )webView shouldStartLoadWithRequest:(NSURLRequest )request</code>方法中</p><p>调用js页面点击按钮后保存图片到相册,必须调用系统提供的方法，不能自己自定义方法</p>]]></content>
      
      
        <tags>
            
            <tag> OC, JS </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SDWebImage的用法及原理</title>
      <link href="/2017/02/08/SDWebImage%E5%AD%A6%E4%B9%A0/"/>
      <content type="html"><![CDATA[<h3 id="SDWebImage-介绍"><a href="#SDWebImage-介绍" class="headerlink" title="SDWebImage 介绍"></a>SDWebImage 介绍</h3><p>SDWebImage 是用于网络中下载且缓存图片，并设置图片到对应的控件或上</p><p>Demo: <a href="https://github.com/aTreey/DownImage.git">https://github.com/aTreey/DownImage.git</a></p><ul><li>提供了UIImageView的category用来加载网络图片并且下载的图片的缓存进行管理</li><li>采用异步方式来下载，确保不会阻塞主线程，memory＋disk来缓存网络图片，自动管理缓存</li><li>支持GIF动画，[self.imageView setImageWithURL:[[NSBundle mainBundle] URLForResource:@”xx.gif” withExtension:nil];</li><li>支持WebP格式</li><li>同一个URL的网络图片不会被重复下载</li><li>失效的URL不会被无限重试</li></ul><h3 id="SDWebImage-的使用"><a href="#SDWebImage-的使用" class="headerlink" title="SDWebImage 的使用"></a>SDWebImage 的使用</h3><p>克隆</p><p>git clone <a href="https://github.com/rs/SDWebImage.git">https://github.com/rs/SDWebImage.git</a><br>使用以上命令克隆会报错，框架中Vendors文件夹中的文件未能全部下载导致报错</p><p>解决办法：<a href="https://github.com/rs/SDWebImage/blob/master/Docs/ManualInstallation.md">https://github.com/rs/SDWebImage/blob/master/Docs/ManualInstallation.md</a></p><p>git clone –recursive <a href="https://github.com/rs/SDWebImage.git">https://github.com/rs/SDWebImage.git</a></p><p>文件全部下载</p><p>自定义operation 加入NSOperationQueue中</p><ul><li>自定义NSOperation,<br>重写main方法</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">- (void)main &#123;</span><br><span class="line">@autoreleasepool &#123;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:_urlStr];</span><br><span class="line">    NSData *data = [NSData dataWithContentsOfURL:url];</span><br><span class="line">    UIImage *image = [UIImage imageWithData:data];</span><br><span class="line"></span><br><span class="line">    if (_finishBlock) &#123;</span><br><span class="line">        _finishBlock(image);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>一个NSOperation对象可以通过调用start方法来执行任务，默认是同步执行的。也可以将NSOperation添加到一个NSOperationQueue(操作队列)中去执行，而且是异步执行的<br>创建队列</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (NSOperationQueue *)downLoadQueue &#123;</span><br><span class="line">    if (!_downLoadQueue) _downLoadQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">    return _downLoadQueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>添加一个任务到队列</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[_downLoadQueue addOperation:operation];</span><br><span class="line">添加一组operation, 是否阻塞当前线程</span><br><span class="line"></span><br><span class="line">[_downLoadQueue addOperations:@[operation] waitUntilFinished:NO];</span><br><span class="line">添加一个block 形式的operation</span><br><span class="line"></span><br><span class="line">[_downLoadQueue addOperationWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;执行一个新的线程&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure><p><strong>注意：</strong></p><ol><li><p>NSOperation 添加到 queue之后，通常短时间内就会执行，但是如果存在依赖，或者整个queue被暂停等原因，也可能会需要等待</p></li><li><p>NSOperation添加到queue之后，绝不要修改NSOperation对象的状态，因为NSOperation对象可能会在任何时候运行，因此改变NSOperation对象的依赖或者数据会产生不利的影响，只能查看NSOperation 对象的状态，比如是否正在运行、等待运行、已经完成等</p></li></ol><ul><li>NSOperation 添加依赖，<br>依赖关系不局限于相同的queue 中的NSOperation对象，可以夸队列进行依赖，但是不能循环依赖，</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">// NSOperation 添加依赖</span><br><span class="line">&#123;</span><br><span class="line">    NSOperationQueue *testQueue = [[NSOperationQueue alloc] init];</span><br><span class="line">    NSBlockOperation *operation1 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;operation1 NSThread = %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;operation2 NSThead = %@&quot;, [NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    // 添加依赖，1 依赖于 2，只有2 执行完之后才执行1</span><br><span class="line">    [operation1 addDependency:operation2];</span><br><span class="line">    // 加入到队列</span><br><span class="line">    [testQueue addOperation:operation1];</span><br><span class="line">    [testQueue addOperation:operation2];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>修改Operation的执行顺序<br>对于添加到queue中的operation执行顺序有一下2点决定<br>operation 是否已经准备好，是否添加了依赖<br>根据多有operations的相对优先性来决定，优先等级是operation对象本身的一个属性，默认都是“普通”优先级，可以通过setQueuePriority方法提高和降低优先级，优先级只能用于相同 queue 中的 operation，多个queue中operation的优先级相互独立，因此不同queue中的低优先级的operation可能比高优先级的operation更早执行<br>注意优先级和依赖不能相互替代，优先级只是对已经准备好的operation确定执行顺序，先满足依赖，然后再看已经准备好的operation中的优先级</p></li><li><p>设置 queue 的最大并发数，队列中最多同时运行几条线程<br>虽然NSOperationQueue类设计用于并发执行Operations,你也可以强制单个queue一次只能执行一个Operation。setMaxConcurrentOperationCount:方法可以配置queue的最大并发操作数量。设为1就表示queue每次只能执行一个操作。不过operation执行的顺序仍然依赖于其它因素,比如operation是否准备好和operation的优先级等。因此串行化的operation queue并不等同于GCD中的串行dispatch queue</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 每次只能执行一个操作  </span><br><span class="line">queue.maxConcurrentOperationCount = 1;  </span><br><span class="line">// 或者这样写  </span><br><span class="line">[queue setMaxConcurrentOperationCount:1];</span><br></pre></td></tr></table></figure><ul><li>取消 operations<br>一旦添加到operation queue,queue就拥有了这个Operation对象并且不能被删除,只能取消。调用Operation对象的cancel方法取消单个操作,也可以调用operation queue的cancelAllOperations方法取消当前queue中的所有操作, 使用cancel属性来判断是否已经取消了</li></ul><p>[operation cacel] 只是打了一个死亡标记, 并没有正真意义上的取消,称为 “自杀“,需要在被取消的任务中时时判断是否取消(在程序的关键处), 如果取消,结束任务, 具体是指在自定义的 operation 的main方法中结束</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[queue cancelAllOperations] 由队列来取消，称为 “他杀”</span><br><span class="line"></span><br><span class="line">// 取消单个操作  </span><br><span class="line">[operation cancel];</span><br><span class="line">// 取消queue中所有的操作  </span><br><span class="line">[queue cancelAllOperations];</span><br></pre></td></tr></table></figure><ul><li>等待operation 完成</li></ul><p>为了最佳的性能,你应该设计你的应用尽可能地异步操作,让应用在Operation正在执行时可以去处理其它事情。如果需要在当前线程中处理operation完成后的结果,可以使用NSOperation的waitUntilFinished方法阻塞当前线程，等待operation完成。通常我们应该避免编写这样的代码,阻塞当前线程可能是一种简便的解决方案,但是它引入了更多的串行代码,限制了整个应用的并发性,同时也降低了用户体验。绝对不要在应用主线程中等待一个Operation,只能在第二或次要线程中等待。阻塞主线程将导致应用无法响应用户事件,应用也将表现为无响应。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 会阻塞当前线程，等到某个operation执行完毕  </span><br><span class="line">[operation waitUntilFinished];</span><br></pre></td></tr></table></figure></p><p>除了等待单个Operation完成,你也可以同时等待一个queue中的所有操作,使用NSOperationQueue的waitUntilAllOperationsAreFinished方法。注意：在等待一个 queue时,应用的其它线程仍然可以往queue中添加Operation,因此可能会加长线程的等待时间。</p><p>// 阻塞当前线程，等待queue的所有操作执行完毕<br>[queue waitUntilAllOperationsAreFinished];<br>暂停和继续operation<br>如果你想临时暂停Operations的执行,可以使用queue的setSuspended:方法暂停queue。不过暂停一个queue不会导致正在执行的operation在任务中途暂停,只是简单地阻止调度新Operation执行。你可以在响应用户请求时,暂停一个queue来暂停等待中的任务。稍后根据用户的请求,可以再次调用setSuspended:方法继续queue中operation的执行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// 暂停queue  </span><br><span class="line">[queue setSuspended:YES];  </span><br><span class="line"></span><br><span class="line">// 继续queue  </span><br><span class="line">[queue setSuspended:NO];</span><br></pre></td></tr></table></figure></p><h3 id="增加Manager管理类，"><a href="#增加Manager管理类，" class="headerlink" title="增加Manager管理类，"></a>增加Manager管理类，</h3><p>作用：</p><ul><li>下载队列</li><li>图像缓存</li><li>操作缓存（内存缓存）</li><li>沙盒缓存</li><li>防止错乱,取消老的未开始下载的操作</li><li>图片显示逻辑：内存缓存 – 沙盒缓存 – 网络下载</li><li>图片缓存逻辑：下载完成 – 缓存沙盒 – 加载到内存</li></ul><p>注意：缓存到本地时只能保存property列表里的对象（NSData, NSDate, NSNumber, NSString, NSArray, NSDictory）, 图片需要转化为二进制数据</p><h3 id="SDWebImage"><a href="#SDWebImage" class="headerlink" title="SDWebImage"></a>SDWebImage</h3><ul><li>SDWebImageDownloader 下完图片后都需要手动设置给UIImageView</li><li>SDWebImageManager 下完图片后都需要手动设置给UIImageView</li><li>下载后要显示可以使用 sd_setImageWithURL 方法</li></ul>]]></content>
      
      
        <tags>
            
            <tag> SDWebImage </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WKWebiView 使用</title>
      <link href="/2017/02/02/iOS%E9%9D%99%E6%80%81%E5%BA%93%E5%8A%A8%E6%80%81%E5%BA%93/"/>
      <content type="html"><![CDATA[<h3 id="iOS中静态库动态库介绍及编译"><a href="#iOS中静态库动态库介绍及编译" class="headerlink" title="iOS中静态库动态库介绍及编译"></a>iOS中静态库动态库介绍及编译</h3><ul><li>静态库</li></ul><p>iOS中根据源码的公开情况可分为2种</p><ul><li>开源库<br>源代码公开，能够看到具体的代码实现</li></ul><p>比如 SDWebImage AFNetworking。。。</p><ul><li><p>闭源库<br>不公开源代码， 是经过编译后的二进制文件， 看不到具体实现<br>主要分为：静态库、动态库</p></li><li><p>存在形式</p></li></ul><p>静态库： .a 和 .framework<br>动态库：.tbd 和 .framework (iOS 9 之前是 .dylib, iOS 9 之后取消了 .dylib 而使用 .tbd 来代替 .dylib )</p><p>.framework 的库可以是静态库也可以是静态库， 凡是系统的 .framework 都是动态库，第三方的基本上全是静态中</p><ul><li>两者区别</li></ul><p>静态库：链接时会被完整的复制到可执行文件中，每次被使用都会被复制<br>动态库：链接时不复制，程序运行时由系统动态加载到内存中，供程序调用，系统只加载一次，多个程序可以公用，节省内存</p><h3 id="静态库编译"><a href="#静态库编译" class="headerlink" title="静态库编译"></a>静态库编译</h3><p>编译时如果使用的是模拟器，生成的 .a 只能模拟器用，真机不可用，生成的 .a 文件在 Debug-iphonesimulator 文件夹下</p><p>编译时如果使用 generic iOS Device，生成的 .a 只能真机而模拟器不可用，生成的 .a 文件在 Debug-iphoneos 文件夹下</p><p>编译静态库时，自己手动创建的类的头文件不会被导出，只是默认导出创建工程时类的头文件</p><p>导出手动添加类的头文件，点击工程名称 –&gt; build Phases –&gt; Copy Files 添加头文件，然后编译</p><ul><li>架构种类</li></ul><p>模拟器：i386 32位架构 (4s~5) ／ x86_64 64位架构 (5s以后机型)<br>真机：armv7 32位架构 (4~4s) ／ armv7s 特殊架构 (5~5C) ／ arm64 64位架构 (5s 以后机型)</p><ul><li><p>架构查看<br>lipo -info xxxx.a<br>默认生成模拟器只生成一种架构 i386 x86_64；真机默认导出两种架构 armv7 ／ arm64</p></li><li><p>合并多个架构</p></li></ul><p>将模拟器的多个架构合并，项目名称–&gt;Build Settings –&gt; Achitectures –&gt; Build Active Architecture Only –&gt; Debug设置为NO<br>合并真机多个架构 按照以上方法运行真机即可<br>合并真机和模拟器架构 cd products lipo -create Debug-iphoneos/xxx.a Debug-iphonessimulator/xxx.a -output xx.a<br>合成 5 个架构 在Build Setting –&gt; Architectures 中手动添加三种架构,再编译合并</p><ul><li>静态库报错</li></ul><p>Undefined symbols for architecture （arm64 ／ armv7 ／ armv7s ／ i386 ／ x86_64），架构包导入出错，静态库有真机与模拟器</p>]]></content>
      
      
        <tags>
            
            <tag> WKWebView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>异步下载图片</title>
      <link href="/2017/01/18/%E5%BC%82%E6%AD%A5%E4%B8%8B%E8%BD%BD%E5%9B%BE%E7%89%87/"/>
      <content type="html"><![CDATA[<h3 id="异步下载"><a href="#异步下载" class="headerlink" title="异步下载"></a>异步下载</h3><p>同步发送网络请求会卡UI线程，采用异步来下载图片。</p><p><strong>异步下载存在的问题</strong></p><ul><li><p>错行问题</p><ul><li>解决：使用MVC模式，使数据一对一可解决，</li><li>在MVC中增加image属性后，会导致单个模式的体积增大</li><li>内存占用</li><li>当接收到内存警告时清空图片时需要遍历模型中将image置为nil</li><li>将图片用字典缓存起来达到一对一, 清空内存中的图片时只需要remove字典就ok</li><li>创建下载任务的字典，在开始下载时将正在下载的URL写入到字典中下载完成后将字典中对应的值移除，写入防止来回滑动时重复发送网络请求，下载完后移除是为了防止如果接受到内存警告后下载的图片都已清除，但是下载任务的字典的值为移除就不会再一次去下载图片</li><li><p>缓存下载的图片到沙盒中</p></li><li><p>获取图片下载路径最后一个分隔符后面的字符串作为图片名保存</p></li></ul></li></ul><p><code>stringByAppendingPathComponent</code> 和 <code>stringByAppendingString</code> 两个方法有区别</p><p><strong>stringByAppendingString 方法是获取caches文件名，在文件夹名后面拼接字符串，在caches上一级目录下创建文件，和caches文件夹属于同一个级别</strong></p><pre><code>// 获取caches文件路径NSString *cachesPath = NSSearchPathForDirectoriesInDomains(NSCachesDirectory, NSUserDomainMask, YES);NSString *URL = @&quot;http://wwww.baidu.com/image/123456.png&quot;;NSString *imageName = [URL lastPathComponent];// 拼接路径// 此方法生成的路径在caches文件下目录下NSString *filePath = [cachesPath stringByAppendingPathComponent];// 读取图片if (内存中没有) {    // 沙盒读取    UIImage *sandBoxImage = [UIImage imageWithContetsOfFile:filePath];    **加入到内存中，方便下次加载**} if (sandBoxImage == nil) {    // 下载图片}// 写入到沙盒if (imageData != nil) {    [imageData writeToFile: filePath atomically:NO];}</code></pre>]]></content>
      
      
        <tags>
            
            <tag> 异步 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Quartz 2D绘制形状(二)</title>
      <link href="/2016/12/10/Quartz2D%E7%BB%98%E5%88%B6%E5%BD%A2%E7%8A%B6/"/>
      <content type="html"><![CDATA[<p>使用Quartz 2D绘制圆弧，扇形，下载进度以及绘制的图形的填充和描边属性的设置.<br>将贝塞尔路径添加到图形上下文中<br>图形上下文中的状态保存和恢复<br>对图形上下文进行矩阵操作（平移，缩放，选转），实现一些特殊效果</p><h3 id="使用贝塞尔曲线绘制矩形"><a href="#使用贝塞尔曲线绘制矩形" class="headerlink" title="使用贝塞尔曲线绘制矩形"></a>使用贝塞尔曲线绘制矩形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithRect:CGRectMake(0, 0, 20, 30)];</span><br><span class="line">    [[UIColor magentaColor] setStroke];</span><br><span class="line">    [[UIColor brownColor] setFill];</span><br><span class="line">    [path fill]; // 填充</span><br><span class="line">    [path stroke]; // 描边</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="圆角矩形"><a href="#圆角矩形" class="headerlink" title="圆角矩形"></a>圆角矩形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 绘制圆角矩形</span><br><span class="line">&#123;</span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(35, 10, 50, 70) cornerRadius:5.0];</span><br><span class="line">    [[UIColor magentaColor] setStroke];</span><br><span class="line">    [[UIColor cyanColor] setFill];</span><br><span class="line">    [path fill];</span><br><span class="line">    [path stroke];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制圆"><a href="#绘制圆" class="headerlink" title="绘制圆"></a>绘制圆</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">// 画圆</span><br><span class="line">&#123;</span><br><span class="line">    UIBezierPath *path = [UIBezierPath bezierPathWithRoundedRect:CGRectMake(90, 5, 40, 40) cornerRadius:20.0];</span><br><span class="line">    [[UIColor purpleColor] setStroke];</span><br><span class="line">    [[UIColor magentaColor] setFill];</span><br><span class="line">    [path fill];</span><br><span class="line">    [path stroke];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="绘制扇形"><a href="#绘制扇形" class="headerlink" title="绘制扇形"></a>绘制扇形</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">CGPoint center = CGPointMake(200, 50);</span><br><span class="line">UIBezierPath *sectorPath = [UIBezierPath bezierPathWithArcCenter:center radius:100 startAngle:0 endAngle:M_PI_4 clockwise:YES];</span><br><span class="line">[sectorPath addLineToPoint:center];</span><br><span class="line">[[UIColor brownColor] setStroke];</span><br><span class="line">[sectorPath fill];</span><br><span class="line">[sectorPath stroke];</span><br></pre></td></tr></table></figure><h3 id="绘制圆弧"><a href="#绘制圆弧" class="headerlink" title="绘制圆弧"></a>绘制圆弧</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 绘制圆弧</span><br><span class="line">* 参数1: 圆心坐标</span><br><span class="line">* 参数2: 半径</span><br><span class="line">* 参数3: 开始角度</span><br><span class="line">* 参数4: 结束角度 使用弧度制表示</span><br><span class="line">* 参数5: clockwis顺时针方法的</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">UIBezierPath *circuLarArcPath = [UIBezierPath bezierPathWithArcCenter:CGPointMake(100, 60) radius:50.0 startAngle:0 endAngle:M_PI_2 clockwise:YES];</span><br><span class="line"></span><br><span class="line">[circuLarArcPath moveToPoint:CGPointMake(100, 60)];</span><br><span class="line"></span><br><span class="line">[[UIColor magentaColor] setStroke];</span><br><span class="line">[[UIColor brownColor] setFill];</span><br><span class="line">[circuLarArcPath stroke];</span><br><span class="line">[circuLarArcPath fill];</span><br></pre></td></tr></table></figure><h3 id="绘制文字"><a href="#绘制文字" class="headerlink" title="绘制文字"></a>绘制文字</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 绘制文字</span><br><span class="line"> * drawAtPoint 不能换行，当文字过多过长时不会有效果</span><br><span class="line"> * 使用 drawInRect 可以实现换行</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">NSString *text = @&quot;我是绘制文字价格就看过几个框架刚开始大家高考的感觉是快乐的关键时刻大家赶快来时的结果看了风水格局来看就哭了感觉树大根深来对抗肌肤抵抗力&quot;;</span><br><span class="line"></span><br><span class="line">NSMutableDictionary *attributeDict  = [NSMutableDictionary dictionary];</span><br><span class="line">attributeDict[NSFontAttributeName] = [UIFont systemFontOfSize:18];</span><br><span class="line"></span><br><span class="line">// 字体颜色</span><br><span class="line">attributeDict[NSForegroundColorAttributeName] = [UIColor greenColor];</span><br><span class="line">// 描边颜色</span><br><span class="line">attributeDict[NSStrokeColorAttributeName] = [UIColor yellowColor];</span><br><span class="line">// 描边宽度</span><br><span class="line">attributeDict[NSStrokeWidthAttributeName] = @1;</span><br><span class="line">//  阴影</span><br><span class="line">NSShadow *shadow = [[NSShadow alloc] init];</span><br><span class="line">shadow.shadowColor = [UIColor redColor];</span><br><span class="line">shadow.shadowOffset = CGSizeMake(1.0, 1.0);</span><br><span class="line"></span><br><span class="line">attributeDict[NSShadowAttributeName] = shadow;</span><br><span class="line"></span><br><span class="line">// 可以换行</span><br><span class="line">[text drawInRect:self.bounds withAttributes:attributeDict];</span><br><span class="line"></span><br><span class="line">// 不换行</span><br><span class="line">[text drawAtPoint:CGPointZero withAttributes:attributeDict];</span><br></pre></td></tr></table></figure><h3 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 绘制图片</span><br><span class="line"> * drawAtPoint 默认绘制的内容尺寸和图片的尺寸一样大</span><br><span class="line"> *</span><br><span class="line"> */</span><br><span class="line"></span><br><span class="line">- (void)drawImage &#123;</span><br><span class="line"></span><br><span class="line">    UIImage *image = [UIImage imageNamed:@&quot;wc_dk&quot;];</span><br><span class="line">    UIImage *image1 = [UIImage imageNamed:@&quot;wc_hq&quot;];</span><br><span class="line"></span><br><span class="line">    [image drawAtPoint:CGPointMake(10, 90)];</span><br><span class="line">    [image1 drawAtPoint:CGPointMake(70, 80)];</span><br><span class="line"></span><br><span class="line">    // 绘制在控件内部，和控件大小一致</span><br><span class="line">    [image1 drawInRect:self.bounds];</span><br><span class="line"></span><br><span class="line">    // 以平铺的方式绘制在控件的内部</span><br><span class="line">    [image1 drawAsPatternInRect:self.bounds];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="圆形下载进度的绘制"><a href="#圆形下载进度的绘制" class="headerlink" title="圆形下载进度的绘制"></a>圆形下载进度的绘制</h3><p>drawRect 方法不能手动调用，因为图形上下文不能手动创建<br>需要调用setNeedsDisplay方法来重绘，系统会创建图形上下文<br>绘制时用到的定时器，一般不使用NSTimer定时器，因为调度优先级比较低，不会被准时带,界面会出现卡顿的现象<br>CADisplayLink 每次刷新屏幕的时候就会调用，1s刷新 60 次<br>setNeedsDisplay调用此方法时并不是立即调用drawRect方法，只是给给当前控件添加刷新标记，直到下一次屏幕刷新的时候才调用drawRect 方法，正好与CADisplayLink 方法一致，所以界面流畅不会卡顿<br>图形上下文状态栈</p><p>UIBezierPath图形上下文和CGContextRef的图形上下文不是同一个图形上下文</p><p>可以将贝塞尔路径添加到图形上下文中</p><p>也可以保存当前的图形上下文，CGContextSaveGState(ctx);<br>在下一次使用时可以恢复，CGContextRestoreGState(ctx);<br>画两种不同状态的线条</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 图形上下文栈的理解</span><br><span class="line">* 画两条状态不同的线段</span><br><span class="line">*/</span><br><span class="line"></span><br><span class="line">// 获取上下文</span><br><span class="line">CGContextRef ctx = UIGraphicsGetCurrentContext();</span><br><span class="line"></span><br><span class="line">// 第一条</span><br><span class="line">UIBezierPath *path = [UIBezierPath bezierPath];</span><br><span class="line">[path moveToPoint:CGPointMake(10, 60)];</span><br><span class="line">[path addLineToPoint:CGPointMake(240, 60)];</span><br><span class="line"></span><br><span class="line">// 把路径添加到上下文</span><br><span class="line">CGContextAddPath(ctx, path.CGPath);</span><br><span class="line"></span><br><span class="line">// 保存上下的状态</span><br><span class="line">CGContextSaveGState(ctx);</span><br><span class="line"></span><br><span class="line">// 设置当前状态</span><br><span class="line">[[UIColor greenColor] setStroke];</span><br><span class="line">//此时设置path 的状态无效，需要设置当前上下文的状态</span><br><span class="line">path.lineWidth = 5.0;</span><br><span class="line">CGContextSetLineWidth(ctx, 5.0);</span><br><span class="line"></span><br><span class="line">// 渲染上下文</span><br><span class="line">CGContextStrokePath(ctx);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 第二根</span><br><span class="line"></span><br><span class="line">// 可使用第一根的路径，因为每次绘制完成之后都会清除</span><br><span class="line">path = [UIBezierPath bezierPath];</span><br><span class="line">[path moveToPoint:CGPointMake(60, 10)];</span><br><span class="line">[path addLineToPoint:CGPointMake(60, 240)];</span><br><span class="line"></span><br><span class="line">// 添加路径到上下文 需要转换为CGPath</span><br><span class="line">CGContextAddPath(ctx, path.CGPath);</span><br><span class="line"></span><br><span class="line">// 还原之前保存的上下文状态</span><br><span class="line">CGContextRestoreGState(ctx);</span><br><span class="line">CGContextStrokePath(ctx);</span><br><span class="line">图形上下文矩阵</span><br><span class="line"></span><br><span class="line">// 使用矩阵</span><br><span class="line"></span><br><span class="line">    // 获取上下文</span><br><span class="line">    CGContextRef ctx = UIGraphicsGetCurrentContext();</span><br><span class="line"></span><br><span class="line">    // 使用贝塞尔路径</span><br><span class="line">    UIBezierPath *ovalPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(-150, -100, 300, 200)];</span><br><span class="line">    [[UIColor cyanColor] setFill];</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 以上绘制的图形有一部分看不到，通过对上下文矩阵操作来实现，平移上下文</span><br><span class="line">    // 操作矩阵必须在添加路径之前</span><br><span class="line"></span><br><span class="line">    // 平移</span><br><span class="line">    CGContextTranslateCTM(ctx, 150, 100);</span><br><span class="line"></span><br><span class="line">    // 缩放</span><br><span class="line">    CGContextScaleCTM(ctx, 0.5, 0.5);</span><br><span class="line"></span><br><span class="line">    // 旋转</span><br><span class="line">    // 可以实现点无法计算时的效果</span><br><span class="line">    CGContextRotateCTM(ctx, M_PI_4);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    // 添加路径到上下文</span><br><span class="line">    CGContextAddPath(ctx, ovalPath.CGPath);</span><br><span class="line"></span><br><span class="line">    // 操作矩阵放在添加路径之后无效果</span><br><span class="line">//  CGContextTranslateCTM(ctx, 150, 100);</span><br><span class="line"></span><br><span class="line">    CGContextFillPath(ctx);</span><br><span class="line"></span><br><span class="line">    // 正常的绘制椭圆</span><br><span class="line">//    UIBezierPath *ovalPath = [UIBezierPath bezierPathWithOvalInRect:CGRectMake(50, 20, 200, 100)];</span><br><span class="line">//    ovalPath.lineWidth = 4.0;</span><br><span class="line">//    [[UIColor magentaColor] setFill];</span><br><span class="line">//    [[UIColor yellowColor] setStroke];</span><br><span class="line">//    [ovalPath stroke];</span><br><span class="line">//    [ovalPath fill];</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> Quartz 2D </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>GCD实现按钮定时亮起</title>
      <link href="/2016/12/05/GCD%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%92%AE%E5%AE%9A%E6%97%B6%E4%BA%AE%E8%B5%B7/"/>
      <content type="html"><![CDATA[<p><strong>某些时候需要按钮不能连续点击，需要在一定的时间之后才可以允许交互，或者是实现类似发送验证码的按钮效果，具体做法是采用定时器</strong></p><h2 id="使用GCD定时器"><a href="#使用GCD定时器" class="headerlink" title="使用GCD定时器"></a>使用GCD定时器</h2><h3 id="创建定时器对象"><a href="#创建定时器对象" class="headerlink" title="创建定时器对象"></a>创建定时器对象</h3><pre><code>__block NSInteger time = 30; // 需要强应用</code></pre><h3 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h3><pre><code>dispatch_queue_t queue = dispatch_get_global_queue(0, 0);</code></pre><h3 id="创建dispatch源-定时器"><a href="#创建dispatch源-定时器" class="headerlink" title="创建dispatch源(定时器)"></a>创建dispatch源(定时器)</h3><pre><code>(dispatach_source…timer..)</code></pre><ul><li><p>01参数:要创建的source 是什么类型的， </p><p>  <code>(DISPATCH_SOURCE_TYPE_TIMER)定时器</code></p></li><li><p>04参数:队列 —-线程 决定block 在哪个线程中调用</p></li></ul><p>代码</p><pre><code>dispatch_source_t _timer = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, queue);</code></pre><h3 id="设置定时器"><a href="#设置定时器" class="headerlink" title="设置定时器"></a>设置定时器</h3><ul><li><p>01参数:定时器对象</p></li><li><p>02参数:开始时间 (DISPATCH_TIME_NOW) 什么时候开始执行第一次任务</p></li><li><p>03参数:间隔时间 GCD时间单位:纳秒</p></li><li><p>04参数:leewayInSeconds精准度:允许的误差: 0 表示绝对精准</p></li></ul><p>code:</p><pre><code>dispatch_source_set_timer(_timer, dispatch_walltime(NULL, 0), 1.0 * NSEC_PER_SEC, 0);</code></pre><h3 id="定时器每隔一段时间就要执行任务-block回调"><a href="#定时器每隔一段时间就要执行任务-block回调" class="headerlink" title="定时器每隔一段时间就要执行任务(block回调)"></a>定时器每隔一段时间就要执行任务(block回调)</h3><pre><code>dispatch_source_set_event_handler(_timer, ^{    if (time &lt;= 0) {        dispatch_source_cancel(_timer);        dispatch_async(dispatch_get_main_queue(), ^{            // 设置按钮的样式            [self.button setTitle:@&quot;重新获取验证码&quot; forState:UIControlStateNormal];            [self.button setTitleColor:[UIColor redColor] forState:UIControlStateNormal];            [self.button setUserInteractionEnabled:YES];        });    } else {        NSInteger seconds = time;        dispatch_async(dispatch_get_main_queue(), ^{            [self.button setTitle:[NSString stringWithFormat:@&quot;重新发送(%.2ld)&quot;, seconds] forState:UIControlStateNormal];            [self.button setTitleColor:[UIColor lightGrayColor] forState:UIControlStateNormal];            [self.button setUserInteractionEnabled:NO];        });        time--;    }});</code></pre><h3 id="启动定时器-默认是停止的"><a href="#启动定时器-默认是停止的" class="headerlink" title="启动定时器(默认是停止的)"></a>启动定时器(默认是停止的)</h3><pre><code>dispatch_resume(timer);</code></pre>]]></content>
      
      
        <tags>
            
            <tag> GCD </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Quartz2D绘制曲线</title>
      <link href="/2016/12/04/Quartz2D%E7%BB%98%E5%88%B6%E6%9B%B2%E7%BA%BF/"/>
      <content type="html"><![CDATA[<p>使用函数绘制曲线</p><p>Quartz 2D提供了CGContextAddCurveToPoint() 函数和CGContextAddQuadCurveToPoint()两个函数来向当前上下文添加曲线，前者用于添加贝塞尔曲线，后者用于添加二次曲线。<br>确定一条贝塞尔曲线需要4个点：开始点、第一个控制点、第二个控制点和结束点。</p><p>确定一条二次曲线需要三个点：开始点、控制点和结束点。</p><p>添加贝塞尔曲线</p><pre><code>CGContextAddCurveToPoint()CGContextRef ctx = UIGraphicsGetCurrentContext();// 添加曲线路径// 设置起点CGContextMoveToPoint(ctx, 0, 0);</code></pre><ul><li>参数1: 上下文对象</li><li>参数2: 控制点1X坐标</li><li>参数3: 控制点1Y坐标</li><li>参数4: 控制点2X坐标</li><li>参数5: 控制点2Y坐标</li><li>参数6: 终点x坐标</li><li>参数7: 终点Y坐标</li></ul><p>code:</p><pre><code>CGContextAddCurveToPoint(ctx, 30, 200, 300, 20, 300, 300);// 设置颜色[[UIColor magentaColor] setStroke];// 渲染CGContextStrokePath(ctx);// 关闭图形上下文CGContextClosePath(ctx);添加二次曲线CGContextAddQuadCurveToPoint()// 获取图形上下文CGContextRef ctx = UIGraphicsGetCurrentContext();// 起始点CGContextMoveToPoint(ctx, 20, 10);</code></pre><ul><li>参数: 图形上下文</li><li>参数: 控制点坐标</li><li>参数: 结束点坐标</li></ul><p>添加二次曲线</p><pre><code>CGContextAddQuadCurveToPoint(ctx, 30, 200, 200, 40);[[UIColor cyanColor] setStroke];CGContextStrokePath(ctx);// 关闭图形上下文CGContextClosePath(ctx);</code></pre><p>绘制形状</p><p>使用绘制二次曲线的函数绘制花瓣</p><p>程序中CGContextAddFlower代码分别添加5瓣花朵路径、6瓣花朵路径、7瓣花朵路径，然后使用不同的颜色来填充这些路径。注意到上面的程序并未在每次添加花朵路径后立即关闭，这也是允许的，而且每次填充路径时并不会再次填充前一次已经填充过的路径。这是因为只用程序绘制了CGContextRef当前所包含的路径，系统会自动清除已经绘制的路径。</p><p><strong>注意：每次绘制完成后，CGContextRef会自动清除已经绘制完成的路径</strong></p><p> 该方法负责绘制花朵。<br> n：该参数控制花朵的花瓣数；dx、dy：控制花朵的位置；size：控制花朵的大小；<br> length：控制花瓣的长度</p><pre><code>void CGContextAddFlower(CGContextRef c , NSInteger n                        , CGFloat dx , CGFloat dy , CGFloat size , CGFloat length){    CGContextMoveToPoint(c , dx , dy + size);  // 移动到指定点    CGFloat dig = 2 * M_PI / n;    // 采用循环添加n段二次曲线路径    for(int i = 1; i &lt; n + 1 ; i++)    {        // 计算控制点坐标        CGFloat ctrlX = sin((i - 0.5) * dig) * length + dx;        CGFloat ctrlY= cos((i - 0.5 ) * dig) * length + dy;        // 计算结束点的坐标        CGFloat x = sin(i * dig) * size + dx;        CGFloat y =cos(i * dig) * size + dy;        // 添加二次曲线路径        CGContextAddQuadCurveToPoint(c, ctrlX , ctrlY , x , y);    }}</code></pre><p>绘制花瓣</p><pre><code>- (void)drawStar{    CGContextRef ctx = UIGraphicsGetCurrentContext();  // 获取绘图的CGContextRef    CGContextBeginPath(ctx);  // 开始添加路径    CGContextAddFlower(ctx , 5 , 50 , 100 , 30 , 80);  // 添加5瓣花朵的路径    CGContextSetRGBFillColor(ctx, 1, 0, 0, 1);  // 设置填充颜色    CGContextFillPath(ctx);    CGContextAddFlower(ctx , 6 , 160 , 100 , 30 , 80);  // 添加6瓣花朵的路径    CGContextSetRGBFillColor(ctx, 1, 1, 0, 1);  // 设置填充颜色    CGContextFillPath(ctx);    CGContextAddFlower(ctx , 7 , 270 , 100 , 30 , 80);  // 添加7瓣花朵的路径    CGContextSetRGBFillColor(ctx, 1, 0, 1, 1);  // 设置填充颜色    CGContextFillPath(ctx);    CGContextClosePath(ctx);  // 关闭路径}</code></pre>]]></content>
      
      
        <tags>
            
            <tag> Quartz2D </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Quartz2D 初识</title>
      <link href="/2016/12/04/Quartz2D%E5%88%9D%E8%AF%86/"/>
      <content type="html"><![CDATA[<p><strong>Quartz2D 二维绘图引擎，支持iOS和Mac系统么，可以实现的功能有</strong></p><ul><li>绘制图形: 线条，三角形，矩形，圆，弧等</li><li>绘制文字</li><li>绘制图像或者图片</li><li>读取生成PDF</li><li>截图/裁剪图片</li><li>自定义UI控件</li><li>手势解锁</li><li>图形上下文</li></ul><h2 id="保存绘图信息和状态"><a href="#保存绘图信息和状态" class="headerlink" title="保存绘图信息和状态"></a>保存绘图信息和状态</h2><p>确定输出目标(PDF,Bitmap或者显示器)</p><pre><code>Bitmap Graphics ContextPDF Granhics ContextWindow Graphics ContextLayer Graphics Context</code></pre><p>绘制线段</p><pre><code>- (void)drawLine {    // 获取图形上下文    // 所用的是UIGraphics上下文    CGContextRef ctx = UIGraphicsGetCurrentContext();    // 创建描述路径    CGMutablePathRef path = CGPathCreateMutable();    // 设置起点    // path : 表示给那个路径设置起点    CGPathMoveToPoint(path, NULL, 10, 10);    CGPathAddLineToPoint(path, NULL, 80, 80);    // 添加路径到上下文    CGContextAddPath(ctx, path);    // 渲染    CGContextStrokePath(ctx);}</code></pre><p>系统底层自动将路径添加到图形上下文</p><pre><code>- (void)drawLine2 {    CGContextRef ctx = UIGraphicsGetCurrentContext();    // 描述路径    // 此方法底层会自动将路径添加到图形上下文    CGContextMoveToPoint(ctx, 50, 50);    CGContextAddLineToPoint(ctx, 100, 100);    CGContextSetLineWidth(ctx, 5);    [[UIColor redColor] set];    // 渲染    CGContextStrokePath(ctx);}</code></pre><p>使用C语言函数的封装</p><pre><code>- (void)drawLine3 {    // 使用UIKit 已经封装的功能,面向对象    // 贝塞尔路径    UIBezierPath *path = [UIBezierPath bezierPath];    [path moveToPoint:CGPointMake(10, 10)];    [path addLineToPoint:CGPointMake(50, 50)];    // 绘制路径    [path stroke];}</code></pre><p>绘制多条线段</p><ul><li>绘制多条线,状态不好管理</li><li>默认下一条线的起点是上一条线的终点</li><li>绘制多天不连接的线时需要重新设置起点</li><li>为了方便管理，应该让每一条线对应一条路径</li><li>使用UIBeizerPath</li></ul><p>code:</p><pre><code>- (void)drawMoreLine {    CGContextRef ctx = UIGraphicsGetCurrentContext();    // 描述路径    CGContextMoveToPoint(ctx, 20, 20);    CGContextAddLineToPoint(ctx, 100, 100);    // 设置第二条线的起点    CGContextMoveToPoint(ctx, 20, 30);    CGContextAddLineToPoint(ctx, 150, 100);    // 设置绘图状态要在渲染之前,都是给上下文设置    // 描边颜色    [[UIColor greenColor] setStroke];    // 线宽    CGContextSetLineWidth(ctx, 10);    // 连接样式    // kCGLineJoinMiter,    斜接    // kCGLineJoinRound,    圆角    // kCGLineJoinBevel     平切    CGContextSetLineJoin(ctx, kCGLineJoinBevel);    // 顶角样式,线的顶端效果    CGContextSetLineCap(ctx, kCGLineCapRound);    // 渲染    CGContextStrokePath(ctx);}</code></pre><p>使用UIBezierPath 绘制多条直线并设置不同状态</p><pre><code>- (void)drawUIBezierPahtState {    // 第一条线    UIBezierPath *path = [UIBezierPath bezierPath];    [path moveToPoint:CGPointMake(10, 10)];    [path addLineToPoint:CGPointMake(80, 80)];    path.lineWidth = 20;    path.lineJoinStyle = kCGLineJoinRound;    path.lineCapStyle = kCGLineCapRound;    [[UIColor redColor] setStroke];    [path stroke];    // 第二条线    {        UIBezierPath *path = [UIBezierPath bezierPath];        [path moveToPoint:CGPointMake(40, 70)];        [path addLineToPoint:CGPointMake(150, 40)];        path.lineWidth = 20;        path.lineJoinStyle = kCGLineJoinRound;        path.lineCapStyle = kCGLineCapRound;        [[UIColor greenColor] setStroke];        [path stroke];    }}</code></pre>]]></content>
      
      
        <tags>
            
            <tag> Quartz2D </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WKWebiView 使用</title>
      <link href="/2016/11/22/Quartz2D%E7%BB%98%E5%88%B6%E7%BA%BF%E6%9D%A1/"/>
      <content type="html"><![CDATA[<h4 id="WKWebiView-iOS8-0-出现，性能要远远好于-iOS-2-0时出现的-UIWebView-主要记录WKWebView-的创建和代理方法"><a href="#WKWebiView-iOS8-0-出现，性能要远远好于-iOS-2-0时出现的-UIWebView-主要记录WKWebView-的创建和代理方法" class="headerlink" title="WKWebiView iOS8.0 出现，性能要远远好于 iOS 2.0时出现的 UIWebView,主要记录WKWebView 的创建和代理方法"></a>WKWebiView iOS8.0 出现，性能要远远好于 iOS 2.0时出现的 UIWebView,主要记录WKWebView 的创建和代理方法</h4><h2 id="创建WKWebView"><a href="#创建WKWebView" class="headerlink" title="创建WKWebView"></a>创建WKWebView</h2><pre><code>WKWebView *webView = [[WKWebView alloc] initWithFrame:self.view.bounds];self.webView = webView;[self.view addSubview:webView];webView.UIDelegate = self;webView.navigationDelegate = self;[webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;]]];</code></pre><p>遵守协议 WKNavgationDelegate WKUIDelegate</p><h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><ul><li><p>WKNavgationDelegate 方法</p><ul><li><p>发送请求之前决定是否跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">// 不允许跳转</span><br><span class="line">   decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">NSLog(@&quot;decidePolicyForNavigationAction&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>收到相应之后决定是否跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationResponsePolicyAllow);</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationResponsePolicyCancel);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;decidePolicyForNavigationResponse&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始加载时调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didStartProvisionalNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接受到服务器的跳转请求时调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line">NSLog(@&quot;didReceiveServerRedirectForProvisionalNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>- 页面加载失败时调用 **存在缓存问题**<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;error= %@&quot;, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- 内容开始返回时调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didCommitNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didCommitNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>内容返回成功后调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didFinishNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始返回错误时调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didFailNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>目前不知道什么时候调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler &#123;</span><br><span class="line">NSLog(@&quot;didReceiveAuthenticationChallenge&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>目前不知道什么时候调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView API_AVAILABLE(macosx(10.11), ios(9.0)) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;webViewWebContentProcessDidTerminate&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> WKWebView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WKWebiView 使用</title>
      <link href="/2016/11/22/Swift3.0%E5%AD%A6%E4%B9%A0(%E4%BA%94)/"/>
      <content type="html"><![CDATA[<h4 id="WKWebiView-iOS8-0-出现，性能要远远好于-iOS-2-0时出现的-UIWebView-主要记录WKWebView-的创建和代理方法"><a href="#WKWebiView-iOS8-0-出现，性能要远远好于-iOS-2-0时出现的-UIWebView-主要记录WKWebView-的创建和代理方法" class="headerlink" title="WKWebiView iOS8.0 出现，性能要远远好于 iOS 2.0时出现的 UIWebView,主要记录WKWebView 的创建和代理方法"></a>WKWebiView iOS8.0 出现，性能要远远好于 iOS 2.0时出现的 UIWebView,主要记录WKWebView 的创建和代理方法</h4><h2 id="创建WKWebView"><a href="#创建WKWebView" class="headerlink" title="创建WKWebView"></a>创建WKWebView</h2><pre><code>WKWebView *webView = [[WKWebView alloc] initWithFrame:self.view.bounds];self.webView = webView;[self.view addSubview:webView];webView.UIDelegate = self;webView.navigationDelegate = self;[webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;]]];</code></pre><p>遵守协议 WKNavgationDelegate WKUIDelegate</p><h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><ul><li><p>WKNavgationDelegate 方法</p><ul><li><p>发送请求之前决定是否跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">// 不允许跳转</span><br><span class="line">   decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">NSLog(@&quot;decidePolicyForNavigationAction&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>收到相应之后决定是否跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationResponsePolicyAllow);</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationResponsePolicyCancel);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;decidePolicyForNavigationResponse&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始加载时调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didStartProvisionalNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接受到服务器的跳转请求时调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line">NSLog(@&quot;didReceiveServerRedirectForProvisionalNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>- 页面加载失败时调用 **存在缓存问题**<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;error= %@&quot;, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- 内容开始返回时调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didCommitNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didCommitNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>内容返回成功后调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didFinishNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始返回错误时调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didFailNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>目前不知道什么时候调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler &#123;</span><br><span class="line">NSLog(@&quot;didReceiveAuthenticationChallenge&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>目前不知道什么时候调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView API_AVAILABLE(macosx(10.11), ios(9.0)) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;webViewWebContentProcessDidTerminate&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> WKWebView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WKWebiView 使用</title>
      <link href="/2016/11/22/Swift3.0%E5%AD%A6%E4%B9%A0(%E5%9B%9B)/"/>
      <content type="html"><![CDATA[<h4 id="WKWebiView-iOS8-0-出现，性能要远远好于-iOS-2-0时出现的-UIWebView-主要记录WKWebView-的创建和代理方法"><a href="#WKWebiView-iOS8-0-出现，性能要远远好于-iOS-2-0时出现的-UIWebView-主要记录WKWebView-的创建和代理方法" class="headerlink" title="WKWebiView iOS8.0 出现，性能要远远好于 iOS 2.0时出现的 UIWebView,主要记录WKWebView 的创建和代理方法"></a>WKWebiView iOS8.0 出现，性能要远远好于 iOS 2.0时出现的 UIWebView,主要记录WKWebView 的创建和代理方法</h4><h2 id="创建WKWebView"><a href="#创建WKWebView" class="headerlink" title="创建WKWebView"></a>创建WKWebView</h2><pre><code>WKWebView *webView = [[WKWebView alloc] initWithFrame:self.view.bounds];self.webView = webView;[self.view addSubview:webView];webView.UIDelegate = self;webView.navigationDelegate = self;[webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;]]];</code></pre><p>遵守协议 WKNavgationDelegate WKUIDelegate</p><h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><ul><li><p>WKNavgationDelegate 方法</p><ul><li><p>发送请求之前决定是否跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">// 不允许跳转</span><br><span class="line">   decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">NSLog(@&quot;decidePolicyForNavigationAction&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>收到相应之后决定是否跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationResponsePolicyAllow);</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationResponsePolicyCancel);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;decidePolicyForNavigationResponse&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始加载时调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didStartProvisionalNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接受到服务器的跳转请求时调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line">NSLog(@&quot;didReceiveServerRedirectForProvisionalNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>- 页面加载失败时调用 **存在缓存问题**<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;error= %@&quot;, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- 内容开始返回时调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didCommitNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didCommitNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>内容返回成功后调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didFinishNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始返回错误时调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didFailNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>目前不知道什么时候调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler &#123;</span><br><span class="line">NSLog(@&quot;didReceiveAuthenticationChallenge&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>目前不知道什么时候调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView API_AVAILABLE(macosx(10.11), ios(9.0)) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;webViewWebContentProcessDidTerminate&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> WKWebView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OC中运行时</title>
      <link href="/2016/11/22/OC%20RunTime%E5%AD%A6%E4%B9%A0/"/>
      <content type="html"><![CDATA[<p>RunTime<br>对于C语言，函数的调用在编译的时候会决定调用哪个函数，而对于面向对象的语言对于[调用某个对象的方法或函数]就叫「消息传递」。所以在 Java，C++ 这些语言里[调用某个对象的方法或函数]和 Objective-C 里[向某个对象发送消息]在概念上就是一样的事情,</p><h3 id="RunTime-简介"><a href="#RunTime-简介" class="headerlink" title="RunTime 简介"></a>RunTime 简介</h3><ul><li>RunTime 简称运行时，OC中通常叫运行时机制，主要的是消息机制</li><li>消息机制：在OC中，属于动态调用，在编译的时候并不能决定真正调用哪个函数，只有在真正运行的时候才会根据函数的名称找到对应的函数来调用</li></ul><h3 id="RunTime-作用"><a href="#RunTime-作用" class="headerlink" title="RunTime 作用"></a>RunTime 作用</h3><ul><li>发送消息：让对象发送消息</li><li>交换方法</li><li>动态添加方法</li><li>动态获取属性和方法</li><li>字典转模型</li><li>给分类添加属性</li></ul><p>原理：给分类添加一个属性,重写了setter、getter方法，但是没有生成 _成员变量，需要通过运行时关联到分类中， 其本质上就是给这个类添加关联,存值和取值<br>code</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">self.oldurlPath = urlPath;</span><br><span class="line"></span><br><span class="line">- (void)setOldurlPath:(NSString *)oldurlPath &#123;</span><br><span class="line"></span><br><span class="line">// RunTime 关联</span><br><span class="line">// 第一个参数：给哪个对象添加关联</span><br><span class="line">// 第二个参数：关联的key，通过这个key获取</span><br><span class="line">// 第三个参数：关联的value</span><br><span class="line">// 第四个参数:关联的策略</span><br><span class="line">objc_setAssociatedObject(self, key, oldurlPath, OBJC_ASSOCIATION_COPY_NONATOMIC);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (NSString *)oldurlPath &#123;</span><br><span class="line">    return objc_getAssociatedObject(self, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> RunTime </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>WKWebiView 使用</title>
      <link href="/2016/11/22/WKWebiView%E4%BD%BF%E7%94%A8/"/>
      <content type="html"><![CDATA[<h4 id="WKWebiView-iOS8-0-出现，性能要远远好于-iOS-2-0时出现的-UIWebView-主要记录WKWebView-的创建和代理方法"><a href="#WKWebiView-iOS8-0-出现，性能要远远好于-iOS-2-0时出现的-UIWebView-主要记录WKWebView-的创建和代理方法" class="headerlink" title="WKWebiView iOS8.0 出现，性能要远远好于 iOS 2.0时出现的 UIWebView,主要记录WKWebView 的创建和代理方法"></a>WKWebiView iOS8.0 出现，性能要远远好于 iOS 2.0时出现的 UIWebView,主要记录WKWebView 的创建和代理方法</h4><h2 id="创建WKWebView"><a href="#创建WKWebView" class="headerlink" title="创建WKWebView"></a>创建WKWebView</h2><pre><code>WKWebView *webView = [[WKWebView alloc] initWithFrame:self.view.bounds];self.webView = webView;[self.view addSubview:webView];webView.UIDelegate = self;webView.navigationDelegate = self;[webView loadRequest:[NSURLRequest requestWithURL:[NSURL URLWithString:@&quot;https://www.baidu.com&quot;]]];</code></pre><p>遵守协议 WKNavgationDelegate WKUIDelegate</p><h2 id="代理方法"><a href="#代理方法" class="headerlink" title="代理方法"></a>代理方法</h2><ul><li><p>WKNavgationDelegate 方法</p><ul><li><p>发送请求之前决定是否跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationAction:(WKNavigationAction *)navigationAction decisionHandler:(void (^)(WKNavigationActionPolicy))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationActionPolicyAllow);</span><br><span class="line">// 不允许跳转</span><br><span class="line">   decisionHandler(WKNavigationActionPolicyCancel);</span><br><span class="line">NSLog(@&quot;decidePolicyForNavigationAction&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>收到相应之后决定是否跳转</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView decidePolicyForNavigationResponse:(WKNavigationResponse *)navigationResponse decisionHandler:(void (^)(WKNavigationResponsePolicy))decisionHandler &#123;</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationResponsePolicyAllow);</span><br><span class="line"></span><br><span class="line">decisionHandler(WKNavigationResponsePolicyCancel);</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;decidePolicyForNavigationResponse&quot;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始加载时调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didStartProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didStartProvisionalNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>接受到服务器的跳转请求时调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didReceiveServerRedirectForProvisionalNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line">NSLog(@&quot;didReceiveServerRedirectForProvisionalNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code>- 页面加载失败时调用 **存在缓存问题**<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFailProvisionalNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;error= %@&quot;, error);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- 内容开始返回时调用<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didCommitNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didCommitNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>内容返回成功后调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFinishNavigation:(null_unspecified WKNavigation *)navigation &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didFinishNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开始返回错误时调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didFailNavigation:(null_unspecified WKNavigation *)navigation withError:(NSError *)error &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;didFailNavigation&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>目前不知道什么时候调用</p> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (void)webView:(WKWebView *)webView didReceiveAuthenticationChallenge:(NSURLAuthenticationChallenge *)challenge completionHandler:(void (^)(NSURLSessionAuthChallengeDisposition disposition, NSURLCredential * _Nullable credential))completionHandler &#123;</span><br><span class="line">NSLog(@&quot;didReceiveAuthenticationChallenge&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>目前不知道什么时候调用</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (void)webViewWebContentProcessDidTerminate:(WKWebView *)webView API_AVAILABLE(macosx(10.11), ios(9.0)) &#123;</span><br><span class="line"></span><br><span class="line">NSLog(@&quot;webViewWebContentProcessDidTerminate&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> WKWebView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>git 使用</title>
      <link href="/2016/11/20/git%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<h2 id="使用-git-提交代码"><a href="#使用-git-提交代码" class="headerlink" title="使用 git 提交代码"></a>使用 git 提交代码</h2><ul><li><p>初始化工作目录</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure></li><li><p>配置用户名和邮箱（当前仓库）</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config user.name &quot;aTreey&quot;</span><br><span class="line">git config user.email &quot;480814177@qq.com&quot;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>配置全局的用户名和密码</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;aTreey&quot;</span><br><span class="line">git config --global user.email &quot;480814177@qq.com&quot;</span><br></pre></td></tr></table></figure></li><li><p>创建文件</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">touch main.m</span><br></pre></td></tr></table></figure></li><li><p>添加文件到暂缓区</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add main.m</span><br></pre></td></tr></table></figure></li><li><p>查看文件状态</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git status</span><br></pre></td></tr></table></figure></li><li><p>新添加的文件或者新修改的文件在工作区中，没有添加到暂缓区中</p></li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Untracked files: （红色）</span><br></pre></td></tr></table></figure></code></pre><ul><li>需要添加到暂缓区中</li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add main.m</span><br></pre></td></tr></table></figure></code></pre><ul><li>出现一下提示方可提交</li></ul><pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Changes to be committed: （绿色）</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>给git起别名</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config alias.st &quot;status&quot;</span><br><span class="line">git config alias.ci &quot;commit -m&quot;</span><br></pre></td></tr></table></figure></li><li><p>查看所有版本库日志（只能查看当前版本的以前日志）</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log</span><br></pre></td></tr></table></figure></li><li><p>查看指定文件的版本库日志</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git log 文件名</span><br></pre></td></tr></table></figure></li><li><p>查看所有的操作的日志</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reflog</span><br></pre></td></tr></table></figure></li></ul><h2 id="版本会退"><a href="#版本会退" class="headerlink" title="版本会退"></a>版本会退</h2><ul><li><p>强制回退到当前版本</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure></li><li><p>强制回退到当前版本的上一个版本</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^</span><br></pre></td></tr></table></figure></li><li><p>强制回退到当前版本的上上个版本</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD^^</span><br></pre></td></tr></table></figure></li><li><p>强制回退到当前版本的前100个版本</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD～100</span><br></pre></td></tr></table></figure></li><li><p>强制回退指定版本</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard HEAD 版本号前七位</span><br></pre></td></tr></table></figure></li></ul>]]></content>
      
      
        <tags>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TableView 使用</title>
      <link href="/2016/11/05/TableView%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/"/>
      <content type="html"><![CDATA[<h2 id="tableView-使用总结"><a href="#tableView-使用总结" class="headerlink" title="tableView 使用总结"></a>tableView 使用总结</h2><ul><li><p>字典的 key enumerator 的使用</p></li><li><p>tableViewCell 的 selected 方法可以监听cell 的选中, 使用selected 参数</p></li><li><p>网络慢时点击左边cell右边数据不能及时刷新， 用户看到的还是上一个cell显示的数据</p><ul><li>解决办法: 在网络加载之前就reload数据，让显示空白</li></ul></li><li><p>点击左边的cell时 上拉加载更多控件的显示和隐藏逻辑</p><ul><li>解决办法: 在每次刷新右边数据时，控制footer的显示</li></ul></li></ul><ul><li><p>在numberOfRowsInSection方法中控制</p></li><li><p>每次点击cell之前要结束上一个没有刷新完的，防止奔溃</p></li><li><p>加载更多时</p><p>  在加载第一页时设置currentPage为1，在加载更多的逻辑中 ++currentPage<br>  点击cell加载时上一个加载更多的网络数据还没有回来，在当前请求之前结束掉所有的网络请求<br>  停止之后的刷新控件状态会有错误，没有更多还是还可以加载状态不确定<br>  在点击左边cell后刷新右边的之前需要检查右边tableView 的footer的状态<br>  下拉刷新</p></li><li><p>第一次下拉刷新之后，第二次下拉刷新，将数据添加到数组中会导致两次数据重复</p><ul><li>解决办法：清除以前的所有数据</li></ul></li><li><p>下拉刷新完毕后结束刷新后需要检查footer的状态</p></li><li><p>网络慢时连续点击cell，连发多个请求成功回调时数据显示错乱，或者是数据已经回来了但是还是显示上一个请求正在请求。。。</p><ul><li>解决办法：点击左边某个类别时，结束所有的刷新（上拉和下拉）</li></ul></li><li><p>连续点击发送请求</p><ul><li>解决办法：保存请求参数， 比较上一次参数和当前参数， 如果 ！= 直接return，不让进入成功回调解析数据， 失败的时候也是同样 return，不提示用户</li></ul></li><li><p>控制器正在请求数据时控制器销毁， 导致奔溃</p><ul><li>解决办法：在dealloc 中停止所有的操作</li></ul></li></ul><h2 id="cell-的frame-设置"><a href="#cell-的frame-设置" class="headerlink" title="cell 的frame 设置"></a>cell 的frame 设置</h2><ul><li><p>cell 之间的间隙以及cell的边距 重写frame 在super 之前设置</p><ul><li>设置frame 的x ，width， height 等属性</li></ul></li><li><p>分页的2种做法</p><ul><li><p>下拉刷新</p><p>  page 加载最新的 加载第一页 浪费用户的流量<br>  加载比当前更新的数据， 需要服务器支持，将当前最新的数据id发送给服务器，服务器加载比当前id还大的数据插入到最前面</p></li><li><p>上拉加载</p><p>  将页码发给服务器</p><p>  将最后面的数据的id发给服务器，</p><p>  加载比当前id更小的数据</p></li></ul></li></ul>]]></content>
      
      
        <tags>
            
            <tag> TableView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hexo个人博客搭建</title>
      <link href="/2016/11/05/Hexo%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"/>
      <content type="html"><![CDATA[<h2 id="安装Homebrew"><a href="#安装Homebrew" class="headerlink" title="安装Homebrew"></a>安装Homebrew</h2><ul><li><p>参考官网教程  <a href="http://brew.sh/index_zh-cn.html" target="_blank" rel="noopener">http://brew.sh/index_zh-cn.html</a></p></li><li><p>在终端中输入,如果失败需要用sudo</p></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/usr/bin/ruby -e &quot; (curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;</span><br></pre></td></tr></table></figure><h2 id="安装git"><a href="#安装git" class="headerlink" title="安装git"></a>安装git</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo brew install git</span><br></pre></td></tr></table></figure><h2 id="安装node-js"><a href="#安装node-js" class="headerlink" title="安装node.js"></a>安装node.js</h2><ul><li>[下载安装] (<a href="https://nodejs.org/en/download" target="_blank" rel="noopener">https://nodejs.org/en/download</a>) </li></ul><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><ul><li>需要输入密码： sudo 管理员权限 -g 全局安装</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo</span><br></pre></td></tr></table></figure><h2 id="初始化-执行-hexo-init-命令"><a href="#初始化-执行-hexo-init-命令" class="headerlink" title="初始化 执行 hexo init 命令"></a>初始化 执行 hexo init 命令</h2><ul><li>指定安装文件 blog</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo init blog</span><br></pre></td></tr></table></figure><ul><li>cd 到 文件夹 blog 下，安装 npm</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install</span><br></pre></td></tr></table></figure><ul><li>开启服务 </li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><ul><li>复制终端中的 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 到浏览器中打开</li></ul><h2 id="关联-github"><a href="#关联-github" class="headerlink" title="关联 github"></a>关联 github</h2><ul><li><p>添加 ssh key 到github</p></li><li><p>设置 Mac 显示隐藏文件</p><ul><li><p>在终端执行一下命令后，重启Finder</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">defaults write com.apple.finder AppleShowAllFiles -bool true</span><br></pre></td></tr></table></figure></li></ul></li><li><p>检查 SSH keys 是否存在 github</p><ul><li><p>打开 Finder 前往（command + shit + G）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure></li></ul></li><li><p>如果有文件说明存在 SSH key， 打开 id_rsa.pub 文件，复制里面的信息</p></li><li>进入 Github –&gt; Settings –&gt; SSH keys –&gt; add SSH key<br>任意添加一个title 粘贴内容到key 里，点击Add key 绿色按钮即可。</li></ul><h2 id="创建名字为-用户名-github-io-的仓库"><a href="#创建名字为-用户名-github-io-的仓库" class="headerlink" title="创建名字为 用户名.github.io 的仓库"></a>创建名字为 用户名.github.io 的仓库</h2><p>自行百度。。。。</p><h2 id="配置-hexo"><a href="#配置-hexo" class="headerlink" title="配置 hexo"></a>配置 hexo</h2><ul><li>vim 打开 _config.yml修改 deploy 模块</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim _config.yml</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">type: git</span><br><span class="line">repository: https://github.com/用户名/用户.github.io.git</span><br><span class="line">branch: master</span><br></pre></td></tr></table></figure><p><strong>冒号后需要加空格</strong></p><h2 id="生成-hexo-的静态页面"><a href="#生成-hexo-的静态页面" class="headerlink" title="生成 hexo 的静态页面"></a>生成 hexo 的静态页面</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo generate 后者 hexo g</span><br></pre></td></tr></table></figure><ul><li>报以下错</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR Local hexo not found in ~/blog</span><br><span class="line">ERROR Try runing: &apos;npm install hexo --save&apos;</span><br></pre></td></tr></table></figure><ul><li>执行下面代码</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo --save</span><br></pre></td></tr></table></figure><h2 id="部署-hexo"><a href="#部署-hexo" class="headerlink" title="部署 hexo"></a>部署 hexo</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo deploy 或者 hexo d</span><br></pre></td></tr></table></figure><ul><li>报以下错误</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR Deployer not found: git</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><ul><li>配置 Deloyment 前，需要配置自己的身份信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;yourname&quot;</span><br><span class="line">git config --global user.email &quot;youremail&quot;</span><br></pre></td></tr></table></figure><p><strong>如果执行完以上命令还是不行，删除blog文件下的 .deploy_git 文件重新 hexo deploy</strong></p>]]></content>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>iOS 弹框视图</title>
      <link href="/2016/10/27/iOS%E5%BC%B9%E6%A1%86%E5%BC%8F%E5%9B%BE/"/>
      <content type="html"><![CDATA[<p><strong><code>UIActionSheet</code> <code>UIAlertView</code> <code>UIAlertViewController</code> 的区别</strong></p><h2 id="UIActionSheet"><a href="#UIActionSheet" class="headerlink" title="UIActionSheet"></a>UIActionSheet</h2><ul><li>iOS 8.3 之后过期</li><li>模态弹出，显示在试图的底部 类似菜单提供选择</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIActionSheet *actionSheet = [[UIActionSheet alloc] initWithTitle:@&quot;title&quot; delegate:self cancelButtonTitle:@&quot;取消&quot; destructiveButtonTitle:nil otherButtonTitles:@&quot;按钮1&quot;, @&quot;按钮2&quot;, nil];</span><br><span class="line">[actionSheet showInView:self.view];</span><br></pre></td></tr></table></figure><h2 id="UIAlertView"><a href="#UIAlertView" class="headerlink" title="UIAlertView"></a>UIAlertView</h2><ul><li>iOS 9.0 之后过期</li><li>模态弹出，显示在试图的中间位置 类似一个对话框提供选择</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">UIAlertView *alertView = [[UIAlertView alloc] initWithTitle:@&quot;考勤方式&quot; message:nil delegate:self cancelButtonTitle:@&quot;取消&quot; otherButtonTitles:faceBtn, fingerPrintBtn, nil];</span><br><span class="line">[alertView show];</span><br></pre></td></tr></table></figure><h2 id="UIAlertViewController"><a href="#UIAlertViewController" class="headerlink" title="UIAlertViewController"></a>UIAlertViewController</h2><ul><li>iOS 8.0 起可以使用</li><li><code>style</code> : 默认样式, 类似 <code>UIActionSheet</code> 列表形式 </li><li><code>style</code> 为：<code>UIAlertControllerStyleAlert</code> 对话框形式</li><li>设置按钮的样式</li></ul><p>如果修改 UIAlertAction 中stye 为：</p><p>UIAlertActionStyleCancel<br>取消按钮会和其他按钮分开</p><p>如果修改 UIAlertAction 中stye 为：</p><p>UIAlertActionStyleDestructive<br>取消按钮会以红色警告的方式显示， 但是按钮之间不会分开</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">UIAlertController *alert = [UIAlertController alertControllerWithTitle:@&quot;考勤方式&quot; message:nil preferredStyle:UIAlertControllerStyleActionSheet];</span><br><span class="line">UIAlertAction *faceBtn = [UIAlertAction actionWithTitle:@&quot;人脸识别&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;&#125;];</span><br><span class="line"></span><br><span class="line">UIAlertAction *fingerPrintBtn = [UIAlertAction actionWithTitle:@&quot;指纹认证&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">UIAlertAction *cancelBtn = [UIAlertAction actionWithTitle:@&quot;取消&quot; style:UIAlertActionStyleDefault handler:^(UIAlertAction * _Nonnull action) &#123;</span><br><span class="line"></span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">[alert addAction:faceBtn];</span><br><span class="line">[alert addAction:fingerPrintBtn];</span><br><span class="line">[alert addAction:cancelBtn];</span><br><span class="line">[self presentViewController:alert animated:YES completion:nil];</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> AlertView </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>本地缓存</title>
      <link href="/2016/10/20/%E6%9C%AC%E5%9C%B0%E7%BC%93%E5%AD%98/"/>
      <content type="html"><![CDATA[<h2 id="保存图片到沙盒"><a href="#保存图片到沙盒" class="headerlink" title="保存图片到沙盒"></a>保存图片到沙盒</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- (void)saveImage:(UIImage *)image InSanBoxWithIndexPath:(NSInteger)indexPath &#123;</span><br><span class="line"></span><br><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, YES);</span><br><span class="line">NSString *filePath = [[paths objectAtIndex:0] stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;pic_%ld.png&quot;, indexPath]];   // 保存文件的名称</span><br><span class="line">[UIImagePNGRepresentation(image)writeToFile:filePath atomically:YES];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="获取沙盒中的图片"><a href="#获取沙盒中的图片" class="headerlink" title="获取沙盒中的图片"></a>获取沙盒中的图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)fetchImageFromSanBoxWithIndexPath:(NSInteger)indexPath</span><br><span class="line">&#123;</span><br><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, YES);</span><br><span class="line">NSString *filePath = [[paths objectAtIndex:0] stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;pic_%ld.png&quot;, indexPath]];   // 保存文件的名称</span><br><span class="line">UIImage *img = [UIImage imageWithContentsOfFile:filePath];</span><br><span class="line">return img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="删除沙盒中的图片"><a href="#删除沙盒中的图片" class="headerlink" title="删除沙盒中的图片"></a>删除沙盒中的图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (BOOL)deleteImageAtIndexPath:(NSInteger)index;</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">NSArray *paths = NSSearchPathForDirectoriesInDomains(NSDocumentDirectory,NSUserDomainMask, YES);</span><br><span class="line">NSString *filePath = [[paths objectAtIndex:0] stringByAppendingPathComponent:[NSString stringWithFormat:@&quot;pic_%ld.png&quot;, index]];</span><br><span class="line"></span><br><span class="line">if([[NSFileManager defaultManager] fileExistsAtPath:filePath]) &#123;</span><br><span class="line">return  [[NSFileManager defaultManager] removeItemAtPath:filePath error:nil];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return NO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="修改图片"><a href="#修改图片" class="headerlink" title="修改图片"></a>修改图片</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">- (UIImage *)fixOrientation:(UIImage *)aImage &#123;</span><br><span class="line"></span><br><span class="line">// No-op if the orientation is already correct</span><br><span class="line">if (aImage.imageOrientation == UIImageOrientationUp)</span><br><span class="line">return aImage;</span><br><span class="line"></span><br><span class="line">// We need to calculate the proper transformation to make the image upright.</span><br><span class="line">// We do it in 2 steps: Rotate if Left/Right/Down, and then flip if Mirrored.</span><br><span class="line">CGAffineTransform transform = CGAffineTransformIdentity;</span><br><span class="line"></span><br><span class="line">switch (aImage.imageOrientation) &#123;</span><br><span class="line">case UIImageOrientationDown:</span><br><span class="line">case UIImageOrientationDownMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, aImage.size.width, aImage.size.height);</span><br><span class="line">transform = CGAffineTransformRotate(transform, M_PI);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case UIImageOrientationLeft:</span><br><span class="line">case UIImageOrientationLeftMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, aImage.size.width, 0);</span><br><span class="line">transform = CGAffineTransformRotate(transform, M_PI_2);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case UIImageOrientationRight:</span><br><span class="line">case UIImageOrientationRightMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, 0, aImage.size.height);</span><br><span class="line">transform = CGAffineTransformRotate(transform, -M_PI_2);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">switch (aImage.imageOrientation) &#123;</span><br><span class="line">case UIImageOrientationUpMirrored:</span><br><span class="line">case UIImageOrientationDownMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, aImage.size.width, 0);</span><br><span class="line">transform = CGAffineTransformScale(transform, -1, 1);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">case UIImageOrientationLeftMirrored:</span><br><span class="line">case UIImageOrientationRightMirrored:</span><br><span class="line">transform = CGAffineTransformTranslate(transform, aImage.size.height, 0);</span><br><span class="line">transform = CGAffineTransformScale(transform, -1, 1);</span><br><span class="line">break;</span><br><span class="line">default:</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// Now we draw the underlying CGImage into a new context, applying the transform</span><br><span class="line">// calculated above.</span><br><span class="line">CGContextRef ctx = CGBitmapContextCreate(NULL, aImage.size.width, aImage.size.height,</span><br><span class="line">CGImageGetBitsPerComponent(aImage.CGImage), 0,</span><br><span class="line">CGImageGetColorSpace(aImage.CGImage),</span><br><span class="line">CGImageGetBitmapInfo(aImage.CGImage));</span><br><span class="line">CGContextConcatCTM(ctx, transform);</span><br><span class="line">switch (aImage.imageOrientation) &#123;</span><br><span class="line">case UIImageOrientationLeft:</span><br><span class="line">case UIImageOrientationLeftMirrored:</span><br><span class="line">case UIImageOrientationRight:</span><br><span class="line">case UIImageOrientationRightMirrored:</span><br><span class="line">// Grr...</span><br><span class="line">CGContextDrawImage(ctx, CGRectMake(0,0,aImage.size.height,aImage.size.width), aImage.CGImage);</span><br><span class="line">break;</span><br><span class="line"></span><br><span class="line">default:</span><br><span class="line">CGContextDrawImage(ctx, CGRectMake(0,0,aImage.size.width,aImage.size.height), aImage.CGImage);</span><br><span class="line">break;</span><br><span class="line">&#125;</span><br><span class="line">CGImageRef cgimg = CGBitmapContextCreateImage(ctx);</span><br><span class="line">UIImage *img = [UIImage imageWithCGImage:cgimg];</span><br><span class="line">CGContextRelease(ctx);</span><br><span class="line">CGImageRelease(cgimg);</span><br><span class="line">return img;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
        <tags>
            
            <tag> 本地缓存 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL 使用</title>
      <link href="/2016/10/13/SQlite%E4%BD%BF%E7%94%A8%E5%AD%A6%E4%B9%A0/"/>
      <content type="html"><![CDATA[<h2 id="常用SQL-语句"><a href="#常用SQL-语句" class="headerlink" title="常用SQL 语句"></a>常用SQL 语句</h2><p>创建一张表</p><pre><code>create table if not exists t_product(productId integer, productName text, productPrice real);</code></pre><p>删除一张表</p><pre><code>drop table if exists t_product;</code></pre><p>插入一条记录</p><p>如果不写某个字段和对应值就会为NUll</p><pre><code>insert into t_product(productId, productName, productPrice) values (0001, &apos;iPhone7&apos;, 6100.8);</code></pre><p>修改记录</p><pre><code>update t_product set productId = 20002 where productName = &apos;iPhone5s&apos;;</code></pre><p>删除</p><pre><code>delete from t_product where productName = &apos;iphone5s&apos;;</code></pre><p><strong>注意：条件语句不能单独存在，只能在修改／删除／查询之后</strong></p><h2 id="简单查询"><a href="#简单查询" class="headerlink" title="简单查询"></a>简单查询</h2><p>准备数据生成sql语句文件</p><pre><code>NSMutableString *mutableString = [NSMutableString string];int productIdValue = arc4random_uniform(1000);NSString *productNameValue = [NSString stringWithFormat:@&quot;iPhone_%d&quot;,1 + arc4random_uniform(8)];CGFloat productPriceValue = 3000 + arc4random_uniform(1000);for (NSInteger i = 0; i &lt; 1000; i++) {    [mutableString appendFormat:@&quot;insert into t_product(productId, productName, productPrice) values (%d, %@, %f); \r\n&quot;, productIdValue, productNameValue, productPriceValue];}// 写入文件[mutableString writeToFile:@&quot;/Users/Apeng/work/Demo/Sqlite/products.sql&quot; atomically:YES encoding:NSUTF8StringEncoding error:NULL];</code></pre><p>生成的sql语句文件</p><p><img src="http://i1.piimg.com/567571/588e899a67c1cce6.png" alt=""></p><p>SQL 查询语句</p><pre><code>select *（表示字段）from t_product（表名）where(条件语句) productId &gt; 100 (字段满足的条件) ;select * from t_product where productPrice &lt; 5000; </code></pre><p><img src="http://p1.bpimg.com/567571/54d2c6ade469b653.png" alt=""><br>or: 或</p><p><img src="http://p1.bqimg.com/567571/c8cd40b4271ec880.png" alt=""></p><p>and: 且</p><p><img src="http://i1.piimg.com/567571/a6b404e93f8bc0eb.png" alt=""></p><p>分页查询</p><p>limit 0,5 （ limit 索引，每页取得数据条数 ）</p><p>第一页 limit 0,5;</p><p>第二页 limit 5,5;</p><p>第三页 limit 10,5;</p><p>第四页 limit 15,5;</p><p>第N页 limit （N - 1）* 5</p><pre><code>select * from t_product where productName = &apos;iPhone_8&apos; and productPrice &lt; 3300 order by productPrice limit 5,5;</code></pre><p><img src="http://i1.piimg.com/567571/29e2799f64db4884.png" alt=""></p><p>排序查询</p><p>order by 默认是从小到大，一般是在某一个结果之后</p><p>默认升序</p><pre><code>// 默认升序select * from t_product where productName = &apos;iPhone_8&apos; and productPrice &lt; 3300 order by productPrice;// 降序select * from t_product where productName = &apos;iPhone_8&apos; and productPrice &lt; 3300 order by productPrice desc;</code></pre><p><img src="http://p1.bqimg.com/567571/c69e4c2790b900b6.png" alt=""></p><p>模糊查询</p><p>关键字搜索 ，% 是指通配符</p><p>SQL 顺序</p><pre><code>select * from 表名 条件语句（模糊匹配）排序语句 分页语句select * from t_product where productName like &apos;%_4&apos; order by productPrice limit 0,5;</code></pre><p><img src="http://i1.piimg.com/567571/4727877c1b85cb0e.png" alt=""></p><p>主键</p><p>数据库的约定俗称,自增长,建议创建表时增加主键，也可以之后再设计表</p><pre><code>CREATE TABLE IF NOT EXISTS t_class (id integer PRIMARY KEY, className text, classNO integer); </code></pre><p>外键约束</p><p>当两张表有关联时，需要使用外键约束，一张表中的字段名所对应的值只能来自于另一张表中</p><p><img src="http://p1.bqimg.com/567571/6b8c31aca88003d0.png" alt=""></p><p>添加外键约束之后的变化</p><p><img src="http://p1.bpimg.com/567571/4e0c9af7ec980748.png" alt=""></p><p>多表查询</p><p>有 <code>t_department</code>（部门表）和 <code>t_employee</code>(员工表)两张表</p><p>需求：在 <code>t_employee</code> 表中查出部门研发部的人员</p><p>1 嵌套查询：</p><p>先查根据部门名称查出部ID，</p><p><img src="http://p1.bqimg.com/567571/29459ada951407a8.png" alt=""></p><p>然后再用部门ID查出员工表中的员工<br><img src="http://i1.piimg.com/567571/0636fdca9e552d99.png" alt=""></p><p>以上两步的代码可合并</p><p>根据部门名称查出部门ID</p><pre><code>SELECT id from t_department WHERE departmentName = &apos;研发部&apos;;</code></pre><p>根据部门id查出这个部门的人员</p><pre><code>SELECT * from t_employee WHERE departmentID = 1;</code></pre><p>合并后为</p><pre><code>select * from t_employee where departmentID = (SELECT id from t_department WHERE departmentName = &apos;研发部&apos;); </code></pre><p>结果为：</p><p><img src="http://i1.piimg.com/567571/fd184b9d631bb19f.png" alt=""></p><ol><li>链接查询</li></ol><p>给表起别名，给字段起别名</p><pre><code>select employee.*, depart.departmentName deptN from t_department depart, t_employee employee;</code></pre><p>/*<em>多表查询之链接查询</em>/</p><pre><code>select t_employee.*, t_department.departmentName FROM t_department, t_employee;</code></pre><p><img src="http://i1.piimg.com/567571/d5bd63824decf7f6.png" alt=""></p><p>消除笛卡尔积</p><pre><code>select employee.*, depart.departmentName deptN from t_department depart, t_employee employee where employee.departmentID = depart.id and employee.departmentID = 1;</code></pre><p><img src="http://i1.piimg.com/567571/b326df9d3150885d.png" alt=""></p>]]></content>
      
      
        <tags>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
