<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>aTreey&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="aTreey&#39;s Blog">
<meta property="og:url" content="https://github.com/aTreey/page/2/index.html">
<meta property="og:site_name" content="aTreey&#39;s Blog">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="aTreey&#39;s Blog">
  
    <link rel="alternate" href="/atom.xml" title="aTreey&#39;s Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">aTreey&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Suche"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://github.com/aTreey"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-iOS 动态设置TableHeaderView高度" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/07/17/iOS 动态设置TableHeaderView高度/" class="article-date">
  <time datetime="2018-07-17T11:12:57.034Z" itemprop="datePublished">2018-07-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="iOS动态设置tableHeaderView高度"><a href="#iOS动态设置tableHeaderView高度" class="headerlink" title="iOS动态设置tableHeaderView高度"></a>iOS动态设置<code>tableHeaderView</code>高度</h2><h4 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h4><p>动态的设置<code>tableHeaderView</code>的高度</p>
<h4 id="遇到的问题："><a href="#遇到的问题：" class="headerlink" title="遇到的问题："></a>遇到的问题：</h4><ul>
<li>设置<code>tableHeaderView</code> 的<code>frame</code>无法实现，有时候会出现<code>tableView</code> 中间的 <code>cell</code> 不显示</li>
<li><p>有时候会导致<code>headerView</code>和<code>cell</code>内容重叠</p>
</li>
<li><p>通过计算控件高度设置frame方式麻烦</p>
</li>
</ul>
<h4 id="正确的步骤"><a href="#正确的步骤" class="headerlink" title="正确的步骤"></a>正确的步骤</h4><ul>
<li>创建HeaderView</li>
<li>取出<code>UITableView</code>的<code>tableHeaderView</code></li>
<li>设置<code>frame</code>大小，调整headerView布局</li>
<li>重新给<code>UITableView</code>的<code>tableHeaderView</code></li>
</ul>
<h4 id="使用AutoLayout"><a href="#使用AutoLayout" class="headerlink" title="使用AutoLayout"></a>使用AutoLayout</h4><p>给<code>UITableView</code>增加分类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">extension UITableView &#123;</span><br><span class="line">    /// set tableHeaderView</span><br><span class="line">    func setTableHeaderView(_ headerView: UIView) &#123;</span><br><span class="line">        headerView.translatesAutoresizingMaskIntoConstraints = false</span><br><span class="line">        self.tableHeaderView = headerView</span><br><span class="line">        // autolayout</span><br><span class="line">        NSLayoutConstraint(item: headerView, attribute: .centerX, relatedBy: .equal, toItem: self, attribute: .centerX, multiplier: 1.0, constant: 0).isActive = true</span><br><span class="line">        NSLayoutConstraint(item: headerView, attribute: .top, relatedBy: .equal, toItem: self, attribute: .top, multiplier: 1.0, constant: 0).isActive = true</span><br><span class="line">        NSLayoutConstraint(item: headerView, attribute: .width, relatedBy: .equal, toItem: self, attribute: .width, multiplier: 1.0, constant: 0).isActive = true</span><br><span class="line">    &#125;</span><br><span class="line">    /// update</span><br><span class="line">    func updateHeaderView() &#123;</span><br><span class="line">        guard let headerView = self.tableHeaderView else &#123; return &#125;</span><br><span class="line">        headerView.layoutIfNeeded()</span><br><span class="line">        let header = self.tableHeaderView</span><br><span class="line">        self.tableHeaderView = header</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2018/07/17/iOS 动态设置TableHeaderView高度/" data-id="cjlgmf6o00021bbfwmmlodm6y" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Masonry:Snapkit使用总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/28/Masonry:Snapkit使用总结/" class="article-date">
  <time datetime="2018-06-28T09:39:38.784Z" itemprop="datePublished">2018-06-28</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Masonry使用"><a href="#Masonry使用" class="headerlink" title="Masonry使用"></a>Masonry使用</h2><p>基本使用官网Demo非常详细，以下总结的是常见问题和技巧</p>
<h3 id="安装遇到的问题"><a href="#安装遇到的问题" class="headerlink" title="安装遇到的问题"></a>安装遇到的问题</h3><ul>
<li><p>pod 安装后出现⚠️，项目运行报错</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[UIView mas_makeConstraints:]: unrecognized selector sent to instance</span><br></pre></td></tr></table></figure>
<p>  <a href="https://github.com/SnapKit/Masonry/issues/188">github</a></p>
<p>  <a href="https://www.jianshu.com/p/3c3fc3cf1218" target="_blank" rel="noopener">解决方法</a></p>
</li>
<li><p>使用<code>lastBaseline</code>属性<code>crash</code></p>
<p>  <a href="https://github.com/SnapKit/Masonry/issues/353">解决办法</a></p>
</li>
</ul>
<h3 id="使用时注意点"><a href="#使用时注意点" class="headerlink" title="使用时注意点"></a>使用时注意点</h3><ul>
<li><p><code>edgesForExtendedLayout</code> 方法</p>
<p>  重写此方法的目的是为了确定布局位置从什么位置开始什么位置结束，</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- (UIRectEdge)edgesForExtendedLayout &#123;</span><br><span class="line">   return UIRectEdgeNone;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>**重写后**
![](https://ws1.sinaimg.cn/large/006tNc79ly1fsgcn3fmo0j30s61iyalk.jpg)

**重写前**
![](https://ws4.sinaimg.cn/large/006tNc79ly1fsgcokvpdwj30s61iy7eq.jpg)
</code></pre><ul>
<li><p><code>translucent</code> 设置<code>UINavigationBar</code>是否半透明, 如果设置了导航栏的<code>style</code> 为<code>UIBarStyleBlackTranslucent</code> 就为true</p>
<p>  <strong>设置为false不透明效果</strong><br>  <img src="https://ws4.sinaimg.cn/large/006tNc79ly1fsgg7ugz8mj30ow0nqq4h.jpg" alt=""></p>
</li>
</ul>
<ul>
<li><p><code>extendedLayoutIncludesOpaqueBars</code> 导航栏不透明条件下是否可以扩展，默认是NO不可以扩展</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">self.navigationController?.navigationBar.isTranslucent = false</span><br><span class="line"> self.extendedLayoutIncludesOpaqueBars = true</span><br></pre></td></tr></table></figure>
</li>
</ul>
<pre><code>**设置不透明，设置可以扩展此时从坐标的（0，0）点开始布局**
![](https://ws2.sinaimg.cn/large/006tNc79ly1fsggem13mjj30ow0j83zy.jpg)    
</code></pre><ul>
<li><p><code>inset</code> 的使用，当约束控件的属性相同时不用再考虑正负值的问题，例如要约束一个控件左边距离另一控件的右边位置时还需要使用负值情况</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[yellowdView makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">       make.height.equalTo(@150);</span><br><span class="line">       make.top.equalTo(self).inset(220);</span><br><span class="line">       make.leading.equalTo(self).inset(10);</span><br><span class="line">       make.trailing.equalTo(greenView.leading).inset(10);</span><br><span class="line">       make.width.equalTo(greenView);</span><br><span class="line">   &#125;];</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>edges</code>的使用，约束边距更方便</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[edgeView remakeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">           make.edges.equalTo(lasView).insets(UIEdgeInsetsMake(10, 5, 5, 5));</span><br><span class="line">       &#125;];</span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p><code>Priority</code> 设置约束的优先级</p>
<ul>
<li><code>priorityHigh</code></li>
<li><code>priorityMedium</code></li>
<li><code>priorityLow</code></li>
</ul>
</li>
<li><p><code>makeConstraints</code>、<code>updateConstraints</code>、<code>remakeConstraints</code>三者区别</p>
<ul>
<li><code>makeConstraints</code> 添加约束</li>
<li><code>updateConstraints</code> 更新约束，更新之前会查找一边控件已经存在的约束，没有就添加，有就更新到最新的约束</li>
<li><code>remakeConstraints</code>删除控件以前的所有约束重新添加约束</li>
</ul>
</li>
<li><p>设置控件或者某一约束的’key’ 方便冲突时⚠️查找</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">	greenView.mas_key = @&quot;greenView&quot;;</span><br><span class="line">    [greenView makeConstraints:^(MASConstraintMaker *make) &#123;</span><br><span class="line">        make.height.equalTo(yellowdView).key(@&quot;greenView-height&quot;);</span><br><span class="line">        make.top.equalTo(yellowdView).key(@&quot;greenView-top&quot;);</span><br><span class="line">        make.width.equalTo(yellowdView).key(@&quot;greenView-width&quot;);</span><br><span class="line">        make.trailing.equalTo(self).inset(10).key(@&quot;greenView-trailing&quot;);</span><br><span class="line">        // 冲突约束</span><br><span class="line">//        make.leading.equalTo(greenView.trailing).inset(10).key(@&quot;greenView-leading&quot;);</span><br><span class="line">    &#125;];</span><br><span class="line">	```	</span><br><span class="line"></span><br><span class="line">- 使用 `MASAttachKeys`批量给`view`设置key</span><br></pre></td></tr></table></figure>
<p>  MASAttachKeys(greenView, yellowdView);</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">	![](https://ws3.sinaimg.cn/large/006tNc79ly1fsgalvd4l6j31a20modnp.jpg)</span><br><span class="line">	</span><br><span class="line">- `dividedBy`和 `multipliedBy` 约束宽高比</span><br></pre></td></tr></table></figure>
<p>  [topInnerView makeConstraints:^(MASConstraintMaker *make) {</p>
<pre><code>// 设置自己的宽高比是3:1
make.width.equalTo( topInnerView.height).multipliedBy(3); // 乘因数

// 设置宽高并且设置他们的优先级最低
make.width.height.lessThanOrEqualTo(topView);
make.width.height.equalTo(topView).priorityLow();

// 设置位置
make.top.equalTo(topView);
</code></pre><p>  }];</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- 多个控件批量约束</span><br></pre></td></tr></table></figure>
<p>  NSValue <em>sizeValue = [NSValue valueWithCGSize:CGSizeMake(100, 100)];<br>  [@[blueView, redView, yellowView] makeConstraints:^(MASConstraintMaker </em>make) {</p>
<pre><code>make.size.equalTo(sizeValue);
</code></pre><p>  }];</p>
<p>  [@[blueView, redView, yellowView] mas_makeConstraints:^(MASConstraintMaker *make) {</p>
<pre><code>make.top.equalTo(self).inset(20);
</code></pre><p>  }];</p>
<p>  [blueView makeConstraints:^(MASConstraintMaker *make) {</p>
<pre><code>make.left.equalTo(self).inset(20);
</code></pre><p>  }];</p>
<p>  [redView makeConstraints:^(MASConstraintMaker *make) {</p>
<pre><code>make.left.equalTo(blueView.right).inset(10);
</code></pre><p>  }];</p>
<p>  [yellowView makeConstraints:^(MASConstraintMaker *make) {</p>
<pre><code>make.left.equalTo(redView.right).inset(10);
</code></pre><p>  }];</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">![批量约束](https://ws1.sinaimg.cn/large/006tNc79ly1fsgaz670hvj30s61iyn2l.jpg)</span><br><span class="line"></span><br><span class="line">**以上代码也可以简化为**</span><br></pre></td></tr></table></figure>
<p>  [redView makeConstraints:^(MASConstraintMaker *make) {</p>
<pre><code>make.left.equalTo(blueView.right).inset(10);
</code></pre><p>  }];</p>
<p>  [yellowView makeConstraints:^(MASConstraintMaker *make) {</p>
<pre><code>make.left.equalTo(redView.right).inset(10);
</code></pre><p>  }];</p>
</li>
</ul>
<pre><code>[blueView makeConstraints:^(MASConstraintMaker *make) {
    make.top.left.equalTo(self);
    make.size.equalTo(@[redView, yellowView, sizeValue]);
}];

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">	![](https://ws2.sinaimg.cn/large/006tNc79ly1fsgbhz8lw5j30s61iyte5.jpg)</span><br><span class="line"></span><br><span class="line">## Snapkit 使用</span><br><span class="line"></span><br><span class="line">- Swift 中`edgesForExtendedLayout:UIRectEdge` 扩展布局的边缘是一个属性，默认是`All`</span><br></pre></td></tr></table></figure>

self.edgesForExtendedLayout = []
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">	在Swift中闭包参数可以使用$0、$1、$2 一次代表第一个，第二个，第三个参数</span><br><span class="line"></span><br><span class="line">- 使用$0 来代替闭包参数</span><br></pre></td></tr></table></figure>

nullDataImageView.snp.makeConstraints {
    $0.top.equalTo(view).offset(44)
    $0.centerX.equalTo(view)
    $0.width.height.equalTo(200)
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">- `deactivate` 和 `activate` 使用</span><br><span class="line">	</span><br><span class="line">	- `activate` 激活指定的约束</span><br><span class="line">	- `deactivate` 移除指定的约束</span><br><span class="line"></span><br><span class="line">	添加约束</span><br></pre></td></tr></table></figure>

nullDataImageView.snp.makeConstraints {
    nullDataViewTopConstraint = $0.top.equalTo(view).offset(80).constraint
    nullDataViewLeftConstraint = $0.left.equalTo(view).inset(10).constraint
    $0.width.height.equalTo(200)
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">移除对应约束，设置约束再激活约束</span><br></pre></td></tr></table></figure>

nullDataViewLeftConstraint?.deactivate()
nullDataViewLeftConstraint?.update(inset: 100)
nullDataViewLeftConstraint?.activate()
UIView.animate(withDuration: 1.5) {
    self.view.layoutIfNeeded()
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 更新约束</span><br><span class="line"></span><br><span class="line">	- 添加约束</span><br></pre></td></tr></table></figure>

nullDataImageView.snp.makeConstraints {
    nullDataViewTopConstraint = $0.top.equalTo(view).offset(64).constraint
    $0.centerX.equalTo(view)
    $0.width.height.equalTo(200)
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 更新约束</span><br></pre></td></tr></table></figure>

nullDataViewTopConstraint?.update(inset: 84)
UIView.animate(withDuration: 0.5, delay: 0, options: .curveEaseOut, animations: {
    self.view.layoutIfNeeded()
}) { (finished) in
    print(&quot;动画执行完毕&quot;)
}
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">	</span><br><span class="line">- 添加`debug`模式中的	`key`使用`labeled()`方法</span><br></pre></td></tr></table></figure>

nullDataImageView.snp.makeConstraints {
    nullDataViewTopConstraint = $0.top.equalTo(view).offset(80).constraint
    nullDataViewLeftConstraint = $0.left.equalTo(view).inset(10).constraint
    $0.width.height.equalTo(200).labeled(&quot;width和height约束&quot;)
}
```
</code></pre><ul>
<li>其他注意点都和<code>Masnory</code>相同</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2018/06/28/Masonry:Snapkit使用总结/" data-id="cjlgmf6n0000dbbfwgr88ow0z" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Swift 基础知识" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/06/19/Swift 基础知识/" class="article-date">
  <time datetime="2018-06-19T07:05:57.922Z" itemprop="datePublished">2018-06-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>Swift 学习</p>
<h2 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h2><h4 id="1-定义-rawValue-为-Int-类型，初始值为1，"><a href="#1-定义-rawValue-为-Int-类型，初始值为1，" class="headerlink" title="1. 定义 rawValue 为 Int 类型，初始值为1，"></a>1. 定义 rawValue 为 Int 类型，初始值为1，</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">enum Month: Int &#123;</span><br><span class="line">    case January = 1</span><br><span class="line">    case February</span><br><span class="line">    case March</span><br><span class="line">    case April</span><br><span class="line">    case May</span><br><span class="line">    case June</span><br><span class="line">    case July</span><br><span class="line">    case August</span><br><span class="line">    case September</span><br><span class="line">    case October</span><br><span class="line">    case November</span><br><span class="line">    case December</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="2-rawValue-的整型值可以不连续"><a href="#2-rawValue-的整型值可以不连续" class="headerlink" title="2. rawValue 的整型值可以不连续"></a>2. rawValue 的整型值可以不连续</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">enum Season: Int &#123;</span><br><span class="line">    case Spring = 1</span><br><span class="line">    case Summer = 5</span><br><span class="line">    case Autumn = 10</span><br><span class="line">    case Winter = 40</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="3-枚举可以是字符串-字符串是变量名和-rawValue-的值相等"><a href="#3-枚举可以是字符串-字符串是变量名和-rawValue-的值相等" class="headerlink" title="3. 枚举可以是字符串,字符串是变量名和 rawValue 的值相等"></a>3. 枚举可以是字符串,字符串是<code>变量名</code>和 <code>rawValue</code> 的值相等</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">enum ProgrammerLanguae: String &#123;</span><br><span class="line">    case Swift</span><br><span class="line">    case OC = &quot;Objective-C&quot;</span><br><span class="line">    case C = &quot;语言&quot;</span><br><span class="line">    case RN = &quot;React-Native&quot;</span><br><span class="line">    case Java</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>rawValue</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">func residueNewYear(month: Month) -&gt; Int &#123;</span><br><span class="line">    return 12 - month.rawValue</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用枚举的Moth的构造函数生成一个Month</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let month = Month(rawValue: 5)</span><br><span class="line">let swift = ProgrammerLanguae.Swift.rawValue</span><br><span class="line">let oc = ProgrammerLanguae.OC</span><br><span class="line">let RN = ProgrammerLanguae.RN.rawValue</span><br></pre></td></tr></table></figure>
<h4 id="4-枚举关联值-associate-value"><a href="#4-枚举关联值-associate-value" class="headerlink" title="4. 枚举关联值 associate value"></a>4. 枚举关联值 associate value</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">enum Status &#123;</span><br><span class="line">    case success(Int)</span><br><span class="line">    case fail(String)</span><br><span class="line">    case null // 未关联值</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func associateValueTest(isSuccess: Bool) -&gt; Status &#123;</span><br><span class="line">    if isSuccess &#123;</span><br><span class="line">        return .success(200)</span><br><span class="line">    &#125;</span><br><span class="line">    return .fail(&quot;失败&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="5-枚举associateValue多个值"><a href="#5-枚举associateValue多个值" class="headerlink" title="5. 枚举associateValue多个值"></a>5. 枚举associateValue多个值</h4><ul>
<li>本质是关联了一个元祖(value0, value1, value2…)</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">enum Shape &#123;</span><br><span class="line">    case Square(width: Double)</span><br><span class="line">    case Reactangle(width: Double, height: Double)</span><br><span class="line">    case Circle(x: Double, y: Double, radius: Double)</span><br><span class="line">    case Point</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let square = Shape.Square(width: 20)</span><br><span class="line">let reactangle = Shape.Reactangle(width: 10, height: 20)</span><br><span class="line">let circle = Shape.Circle(x: 10, y: 10, radius: 20)</span><br><span class="line">let point = Shape.Point</span><br><span class="line"></span><br><span class="line">private func area(shape: Shape) -&gt; Double &#123;</span><br><span class="line">    switch shape &#123;</span><br><span class="line">    case let .Square(width):</span><br><span class="line">        return width * width</span><br><span class="line">    case let .Reactangle(width, height):</span><br><span class="line">        return width * height</span><br><span class="line">    case let .Circle(_, _, radius):</span><br><span class="line">        return radius * radius * Double.pi</span><br><span class="line">    case .Point:</span><br><span class="line">        return 0</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="6-递归枚举"><a href="#6-递归枚举" class="headerlink" title="6. 递归枚举"></a>6. 递归枚举</h4><ul>
<li>定义一个递归算术表达式</li>
<li>使用 indirect 来修饰</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">indirect enum ArithmeticalExpression &#123;</span><br><span class="line">    case Number(Int)</span><br><span class="line">    case Addition(ArithmeticalExpression, ArithmeticalExpression) // + 时两边也是一个表达式</span><br><span class="line">    case Multiplication(ArithmeticalExpression, ArithmeticalExpression) // * 时两边也是一个表达式</span><br><span class="line">    </span><br><span class="line">//    indirect case Addition(ArithmeticalExpression, ArithmeticalExpression) // + 时两边也是一个表达式</span><br><span class="line">//    indirect case Multiplication(ArithmeticalExpression, ArithmeticalExpression) // * 时两边也是一个表达式</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>递归表达式使用 (2+3) * 4</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let two = ArithmeticalExpression.Number(2)</span><br><span class="line">let one = ArithmeticalExpression.Number(3)</span><br><span class="line">let sum = ArithmeticalExpression.Addition(two, one)</span><br><span class="line">let indirectEnumResult = ArithmeticalExpression.Multiplication(sum, ArithmeticalExpression.Number(4))</span><br></pre></td></tr></table></figure>
<ul>
<li>计算表达式值的函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">private func calculate(expression: ArithmeticalExpression) -&gt; Int &#123;</span><br><span class="line">    switch expression &#123;</span><br><span class="line">    case let .Number(value):</span><br><span class="line">        return value</span><br><span class="line">    case let .Addition(left, right):</span><br><span class="line">        return calculate(expression: left) + calculate(expression: right)</span><br><span class="line">    case let .Multiplication(left, right):</span><br><span class="line">        return calculate(expression: left) * calculate(expression: right)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ul>
<li>结构体中的属性值没有初始化时必须使用构造函数来初始化，否则报错</li>
<li></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">struct Location &#123;</span><br><span class="line">    var latitude: Double</span><br><span class="line">    var longitude: Double</span><br><span class="line">    var placeName: String?</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let location1 = Location(latitude: 37.3230, longitude: -122.0322, placeName: &quot;测试&quot;)</span><br></pre></td></tr></table></figure>
<ul>
<li>结构体中属性如果都赋了初始值就可以直接初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">struct Location2 &#123;</span><br><span class="line">    var latitude: Double = 0</span><br><span class="line">    var longitude: Double = 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let location2 = Location2()</span><br></pre></td></tr></table></figure>
<ul>
<li>如果未指定初始值，swift 就不会默认初始化为（不初始化）</li>
<li>当属性值为可选值时此时允许值为nil，那么就允许不通过构造函数来初始化赋值</li>
<li>let 只有一次赋值机会</li>
<li>不管是类还是结构体都应该提供一个全参数的构造函数 <code>init(latitude: Double, longitude: Double, placeName: String?)</code></li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">struct Location3 &#123;</span><br><span class="line">    let latitude: Double</span><br><span class="line">    let longtitude: Double</span><br><span class="line">    var placeName: String?</span><br><span class="line">    </span><br><span class="line">    init(coordinateString: String) &#123;</span><br><span class="line">        let index = coordinateString.index(of: &quot;,&quot;)</span><br><span class="line">        let index1 = coordinateString.index(after: index!)</span><br><span class="line">        let test_1 = coordinateString.prefix(upTo: index!)</span><br><span class="line">        let test_2 = coordinateString.suffix(from: index1)</span><br><span class="line">        </span><br><span class="line">        latitude = Double(test_1)!</span><br><span class="line">        longtitude = Double(test_2)!</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    init(latitude: Double, longitude: Double, placeName: String?) &#123;</span><br><span class="line">        self.latitude = latitude</span><br><span class="line">        self.longtitude = longitude</span><br><span class="line">        self.placeName = placeName</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let test3 = Location3(coordinateString: &quot;12,45&quot;)</span><br></pre></td></tr></table></figure>
<h2 id="类"><a href="#类" class="headerlink" title="类"></a>类</h2><h2 id="属性和方法"><a href="#属性和方法" class="headerlink" title="属性和方法"></a>属性和方法</h2><h4 id="计算型属性"><a href="#计算型属性" class="headerlink" title="计算型属性"></a>计算型属性</h4><h4 id="类型属性"><a href="#类型属性" class="headerlink" title="类型属性"></a>类型属性</h4><h4 id="类型方法"><a href="#类型方法" class="headerlink" title="类型方法"></a>类型方法</h4><h4 id="属性管擦器"><a href="#属性管擦器" class="headerlink" title="属性管擦器"></a>属性管擦器</h4><h4 id="延迟属性"><a href="#延迟属性" class="headerlink" title="延迟属性"></a>延迟属性</h4><h4 id="访问控制"><a href="#访问控制" class="headerlink" title="访问控制"></a>访问控制</h4><h4 id="单利模式"><a href="#单利模式" class="headerlink" title="单利模式"></a>单利模式</h4><h2 id="继承和构造函数"><a href="#继承和构造函数" class="headerlink" title="继承和构造函数"></a>继承和构造函数</h2><h4 id="swift-中继承"><a href="#swift-中继承" class="headerlink" title="swift 中继承"></a>swift 中继承</h4><h4 id="多态性"><a href="#多态性" class="headerlink" title="多态性"></a>多态性</h4><h4 id="属性和函数重载"><a href="#属性和函数重载" class="headerlink" title="属性和函数重载"></a>属性和函数重载</h4><h4 id="子类两段式构造"><a href="#子类两段式构造" class="headerlink" title="子类两段式构造"></a>子类两段式构造</h4><ul>
<li><p>子类构造函数分为两段，第一段是构造自己，第二段是构造父类</p>
<ul>
<li>父类中构造函数</li>
<li>子类要设置一个自己的构造函数</li>
<li>子类构造函数中需要先初始化自己的属性</li>
<li><p>然后在构造函数中调用父类初始化父类构造函数中的相关属性</p>
<p>父类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var sex: Int = 0</span><br><span class="line">    var old: Int = 32</span><br><span class="line">    var desc: String &#123;</span><br><span class="line">        return &quot;我是\(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;Father can Running&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<pre><code>子类

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">class Son: Father &#123;</span><br><span class="line"></span><br><span class="line">    var isSwimming = true</span><br><span class="line">    </span><br><span class="line">    var computer: String</span><br><span class="line">    </span><br><span class="line">    override var desc: String &#123;</span><br><span class="line">        return &quot;Son is \(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    init(name: String, computer: String) &#123;</span><br><span class="line">        self.computer = computer</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>子类两段构造都完成后子类的初始化才完成，可以使用<code>self</code>调用属性或者方法</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">init(name: String, computer: String) &#123;</span><br><span class="line">       self.computer = computer</span><br><span class="line">       self.getToys() // 此代码报错，子类初始化未完成</span><br><span class="line">       super.init(name: name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="便利构造函数和指定构造函数"><a href="#便利构造函数和指定构造函数" class="headerlink" title="便利构造函数和指定构造函数"></a>便利构造函数和指定构造函数</h4><ul>
<li>便利构造函数只能调用自己的指定构造函数</li>
<li>指定构造函数通过一系列的调用都会调用super.init()</li>
<li>便利构造函数无法调用super.init()</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var sex: Int = 0</span><br><span class="line">    var old: Int = 32</span><br><span class="line">    var desc: String &#123;</span><br><span class="line">        return &quot;我是\(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    init(name: String, old: Int) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.old = old</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;Father can Running&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Son: Father &#123;</span><br><span class="line">    var isSwimming = true</span><br><span class="line">    var computer: String</span><br><span class="line">    </span><br><span class="line">    override var desc: String &#123;</span><br><span class="line">        return &quot;Son is \(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 子类指定构造函数,调用了父类的指定构造函数</span><br><span class="line">    init(name: String, computer: String) &#123;</span><br><span class="line">        self.computer = computer</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 子类便利构造函数，调用了指定构造函数</span><br><span class="line">    convenience override init(name: String) &#123;</span><br><span class="line">        let computer = &quot;iMac&quot;</span><br><span class="line">        self.init(name: name, computer: computer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="构造函数继承"><a href="#构造函数继承" class="headerlink" title="构造函数继承"></a>构造函数继承</h4><ul>
<li>子类有可能会继承父类的构造函数</li>
<li>子类没有实现父类的任何指定构造函数；则自动继承父类的所有指定构造函数, 因为继承了指定构造函数所以同时便利构造函数也被继承</li>
</ul>
<p>父类<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    var sex: Int = 0</span><br><span class="line">    var old: Int = 32</span><br><span class="line">    var desc: String &#123;</span><br><span class="line">        return &quot;我是\(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// Father指定构造函数-1</span><br><span class="line">    init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// Father指定构造函数-2</span><br><span class="line">    init(name: String, old: Int) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">        self.old = old</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// Father便利构造函数</span><br><span class="line">    convenience init(old: Int) &#123;</span><br><span class="line">        self.init(name: &quot;Father&quot;, old: old)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    func run() &#123;</span><br><span class="line">        print(&quot;Father can Running&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Son: Father &#123;</span><br><span class="line">    var isSwimming = true</span><br><span class="line">    var computer: String</span><br><span class="line">    var job: String</span><br><span class="line">    </span><br><span class="line">    override var desc: String &#123;</span><br><span class="line">        return &quot;Son is \(name)&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 子类重载的指定构造函数-1</span><br><span class="line">    convenience override init(name: String) &#123;</span><br><span class="line">        self.init(name: name, computer: &quot;Dell&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 子类重载的指定构造函数-2</span><br><span class="line">    override convenience init(name: String, old: Int) &#123;</span><br><span class="line">        self.init(name: name, computer: &quot;acer&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    /// 子类自己的指定构造函数,调用了父类的指定构造函数</span><br><span class="line">    init(name: String, computer: String) &#123;</span><br><span class="line">        self.computer = computer</span><br><span class="line">        self.job = &quot;C#&quot;</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 子类便利构造函数，调用了自己指定构造函数</span><br><span class="line">    convenience init(computer: String) &#123;</span><br><span class="line">        let name = &quot;小张&quot;</span><br><span class="line">        self.init(name: name, computer: computer)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>未实现父类任何的指定构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class Grandson: Son &#123;</span><br><span class="line">    var toy: String = &quot;dog toys&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子类可以调用的构造函数</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let grandSon0 = Grandson(old: 4)</span><br><span class="line">let grandSon1 = Grandson(computer: &quot;Mi&quot;)</span><br><span class="line">let grandSon2 = Grandson(name: &quot;小王&quot;)</span><br><span class="line">let grandSon3 = Grandson(name: &quot;小虎&quot;, computer: &quot;👽&quot;)</span><br><span class="line">let grandSon4 = Grandson(name: &quot;小李&quot;, old: 8)</span><br></pre></td></tr></table></figure>
<ul>
<li>子类实现了父类所有的指定构造函数，则自动继承父类的所有便利构造函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let son0 = Son(old: 30)</span><br><span class="line">let son1 = Son(computer: &quot;Mi&quot;)</span><br><span class="line">let son2 = Son(name: &quot;小王&quot;)</span><br><span class="line">let son3 = Son(name: &quot;小虎&quot;, computer: &quot;👽&quot;)</span><br><span class="line">let son4 = Son(name: &quot;小李&quot;, old: 8)</span><br></pre></td></tr></table></figure>
<h4 id="required-构造函数"><a href="#required-构造函数" class="headerlink" title="required 构造函数"></a>required 构造函数</h4><ul>
<li>父类中有被 required 关键词修饰的构造函数子类必须实现此构造函数</li>
<li>子类实现的此构造函数不需要再使用 override 关键词修饰，需要 required 修饰</li>
</ul>
<p>子类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Father &#123;</span><br><span class="line">    var name: String</span><br><span class="line">    /// Father指定构造函数-1</span><br><span class="line">    // required 修饰的指定构造函数子类中必须实现</span><br><span class="line">    required init(name: String) &#123;</span><br><span class="line">        self.name = name</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>父类</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Son: Father &#123;</span><br><span class="line">    var isSwimming = true</span><br><span class="line">    var computer: String</span><br><span class="line">    </span><br><span class="line">    /// 子类重载的指定构造函数-1</span><br><span class="line">    convenience required init(name: String) &#123;</span><br><span class="line">        self.init(name: name, computer: &quot;Dell&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    /// 子类自己的指定构造函数,调用了父类的指定构造函数</span><br><span class="line">    init(name: String, computer: String) &#123;</span><br><span class="line">        self.computer = computer</span><br><span class="line">        self.job = &quot;C#&quot;</span><br><span class="line">        super.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>子类如果实现了自己的指定构造函数，那么 required 修饰指定构造函数就初始化失败，因为自己实现了指定构造函数所以不能继承父类中的构造函数，此时可以自己实现被required 修饰的便利构造函数</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Son1: Son &#123;</span><br><span class="line">    var sport: String</span><br><span class="line">    </span><br><span class="line">    // 指定构造函数，需要调用父类的指定构造函数</span><br><span class="line">    init(name: String, sport: String) &#123;</span><br><span class="line">        self.sport = sport</span><br><span class="line">        Son.init(name: name)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    // 父类中有被 required 关键词修饰的必须实现的构造函数</span><br><span class="line">    convenience required init(name: String) &#123;</span><br><span class="line">       // fatalError(&quot;init(name:) has not been implemented&quot;)</span><br><span class="line">        // 调用自己的指定构造函数，</span><br><span class="line">        self.init(name: name, sport: &quot;&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2018/06/19/Swift 基础知识/" data-id="cjlgmf6oo002hbbfwp4uvcwur" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-SwiftLint使用" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/03/17/SwiftLint使用/" class="article-date">
  <time datetime="2018-03-17T04:19:58.031Z" itemprop="datePublished">2018-03-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>SwiftLint 将 swift 强制检查代码风格</p>
<p><a href="https://github.com/realm/SwiftLint/blob/master/README_CN.md">教程</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2018/03/17/SwiftLint使用/" data-id="cjlgmf6ni0017bbfwuik347ff" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Mac安装VirtualBox连接U盘" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/02/03/Mac安装VirtualBox连接U盘/" class="article-date">
  <time datetime="2018-02-02T18:41:32.000Z" itemprop="datePublished">2018-02-03</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/02/03/Mac安装VirtualBox连接U盘/">Mac安装VirtualBox连接U盘</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>最近因为某些原因需要再Mac上安装虚拟机,所以选择了VirtualBox安装了<br>win10系统，但是需要再虚拟机的win10中访问U盘数据，遇到的问题是不能连接并且读取到U盘，错误提示不能分配USB内存。。。</p>
<p>网上找了好多办法都胡扯，根本没有解决…</p>
<p>解决方法：<br>1.升级VirtualBox到最新版<br>2.关闭当前的虚拟机中的操作系统<br>3.安装增强工具<br>4.重启VirtualBox，回到Mac桌面推出U盘即可</p>
<p>最重要的就是在第四步</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2018/02/03/Mac安装VirtualBox连接U盘/" data-id="cjlgmf6mu000abbfwqx1p5ca2" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-Block学习探究" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/19/Block学习探究/" class="article-date">
  <time datetime="2018-01-18T16:06:55.000Z" itemprop="datePublished">2018-01-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/19/Block学习探究/">Block学习探究</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="代码及结果"><a href="#代码及结果" class="headerlink" title="代码及结果"></a>代码及结果</h3><ul>
<li><p>普通局部变量</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)block1 &#123;</span><br><span class="line">    </span><br><span class="line">    NSInteger num = 100;</span><br><span class="line">    </span><br><span class="line">    // 定义一个block</span><br><span class="line">    dispatch_block_t block = ^ &#123;</span><br><span class="line">        NSLog(@&quot;block1 -- numer = %zd&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    num = 200;</span><br><span class="line">    </span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>使用__block修饰变量</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)block2 &#123;</span><br><span class="line">    </span><br><span class="line">    __block NSInteger num = 100;</span><br><span class="line">    </span><br><span class="line">    // 定义一个block</span><br><span class="line">    dispatch_block_t block = ^ &#123;</span><br><span class="line">        NSLog(@&quot;block2 -- numer = %zd&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    num = 200;</span><br><span class="line">    </span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>全局变量</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">- (void)block3 &#123;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    // 定义一个block</span><br><span class="line">    dispatch_block_t block = ^ &#123;</span><br><span class="line">        NSLog(@&quot;block3 -- numer = %zd&quot;, blockNum);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    blockNum = 200;</span><br><span class="line">    </span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>静态常量</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">- (void)block4 &#123;</span><br><span class="line">    </span><br><span class="line">    static NSInteger num = 100;</span><br><span class="line">    </span><br><span class="line">    // 定义一个block</span><br><span class="line">    dispatch_block_t block = ^ &#123;</span><br><span class="line">        NSLog(@&quot;block4 -- numer = %zd&quot;, num);</span><br><span class="line">    &#125;;</span><br><span class="line">    </span><br><span class="line">    num = 200;</span><br><span class="line">    </span><br><span class="line">    block();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="运行结果"><a href="#运行结果" class="headerlink" title="运行结果"></a>运行结果</h3><pre><code>2018-01-19 00:04:13.759416+0800 CycleRetain[91251:2382380] block1 -- numer = 100
2018-01-19 00:04:13.760206+0800 CycleRetain[91251:2382380] block2 -- numer = 200
2018-01-19 00:04:13.760473+0800 CycleRetain[91251:2382380] block3 -- numer = 200
2018-01-19 00:04:13.760603+0800 CycleRetain[91251:2382380] block4 -- numer = 200
</code></pre><h3 id="原理及本质"><a href="#原理及本质" class="headerlink" title="原理及本质"></a>原理及本质</h3><p>block 根据创建位置不同,共有三种:栈block,堆block,全局block</p>
<p>使用<strong>block本质就是为了保证栈上和堆上block内访问和修改的是同一个变量,具体的实现是将</strong>block 修饰的变动自动封装成一个结构体,让他在堆上创建<br>基于OC 底层的runtime 机制<br>block 在内部会有一个指向结构体的指针,当调用block的时候其实就是让block找出对应的指针所指的函数地址进行调用。并传入了block自己本身</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2018/01/19/Block学习探究/" data-id="cjlgmf6me0000bbfwlfwansjz" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-常见问题总结-二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/18/常见问题总结-二/" class="article-date">
  <time datetime="2018-01-18T02:23:13.000Z" itemprop="datePublished">2018-01-18</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/18/常见问题总结-二/">面试中常见问题总结(二)</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="非正式协议和正式协议"><a href="#非正式协议和正式协议" class="headerlink" title="非正式协议和正式协议"></a>非正式协议和正式协议</h3><p>非正式协议：凡是给NSObject或者其子类添加的类别都是非正式协议<br>正式协议：使用 @protocol 方式声明的方法列表，有 @require 和 @optional 两种类型</p>
<h3 id="KVC-键值编码"><a href="#KVC-键值编码" class="headerlink" title="KVC 键值编码"></a>KVC 键值编码</h3><p> 之所以可以使用就是因为给 NObject 增加了 NSKeyValueCoding 非正式协议，NSObject 实现了协议，OC中几乎所有的对象都支持KVC，获取值的方法是不通过属性的setter、getter 方法，而是通过属性名称的key间接访问了实例变量，<strong>可以访问私有变量</strong></p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> // 官方注释</span><br><span class="line"> /* Send -setObject:forKey: to the receiver, unless the value is nil, in which case send -removeObjectForKey:.</span><br><span class="line">*/</span><br><span class="line"> - (void)setValue:(nullable ObjectType)value forKey:(NSString *)key;</span><br></pre></td></tr></table></figure>
</code></pre><p>如果为nil, 就会自动过滤掉, 此方法常用在字典中过滤空值</p>
<p>// forKeyPath: 用于符合属性,能够通过层层访问内部属性，相当于调用属性点语法, 拥有forKey 的所有功能</p>
<pre><code><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- (void)setValue:(nullable id)value forKeyPath:(NSString *)keyPath;</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li>实现原理<ul>
<li>利用 setValue: forKeyPath: 赋值</li>
</ul>
<ol>
<li>底层实现还是使用 runtime 给对象发消息，先去查找属性是否有setter方法，存在setter 就会通过 setter 方法复制，</li>
<li>如果没有setter方法，接着查找下是否划线的成员变量，如果有直接给赋值</li>
<li>如果没有下划线的成员变量，查找是否存在和key值相同的属性，如果有就直接给属性赋值</li>
<li>如果没有和key值相同的属性，就会执行 setValue: forUndefinedKey: 抛出一个异常程序奔溃，这也是字典转模型中需要实现这个方法的原因</li>
</ol>
</li>
</ul>
<h3 id="KVO-键值监听"><a href="#KVO-键值监听" class="headerlink" title="KVO 键值监听"></a>KVO 键值监听</h3><p>利用一个key值来找到某个属性并监听某个属性的值的变化发送给观察者，可以理解为简单的观察者模式</p>
<ul>
<li><p>KVO 使用</p>
<ol>
<li><p>为目标对象的属性添加观察者</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (void)testKVO &#123;</span><br><span class="line">    Person *p = [[Person alloc] init];</span><br><span class="line">    self.person = p;</span><br><span class="line">    p.name = @&quot;哈哈&quot;;</span><br><span class="line">    </span><br><span class="line">    [p addObserver:self forKeyPath:@&quot;name&quot; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionOld context:nil];</span><br><span class="line">    </span><br><span class="line">    p.name = @&quot;我不是原来的我!你能监听到我 ？？？&quot;;</span><br><span class="line">    p.name = @&quot;看我七十二变&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
</li>
</ul>
<pre><code>2. 实现监听的方法

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#pragma mark - kvo 回调方法</span><br><span class="line">	- (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary&lt;NSKeyValueChangeKey,id&gt; *)change context:(void *)context &#123;</span><br><span class="line">	    </span><br><span class="line">	    NSLog(@&quot;KVO监听到的对象是 = %@, 值 = %@ , change = %@&quot;, [object class], keyPath, change);</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

3. 移除观察者

<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- (void)dealloc &#123;</span><br><span class="line">   </span><br><span class="line">   [self removeObserver:self forKeyPath:@&quot;name&quot;];</span><br><span class="line">   NSLog(@&quot;-----控制器销毁-----&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li><p>KVO原理</p>
<p>   类的属性被添加了观察者后，OC底层就会通过Runtime 动态的创建一个这个类的派生类，当前类内部的isa 指针指向了这个派生类，在派生类中重写基类被观察属性的 setter 方法，调用前后会调用 willChangeValueForKey, setValueForKey, didChangeValue 方法, 从而达到监听属性值的方法</p>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2018/01/18/常见问题总结-二/" data-id="cjlgmf6o00023bbfwygrty8it" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-面试中常见问题总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/17/面试中常见问题总结/" class="article-date">
  <time datetime="2018-01-17T14:54:12.000Z" itemprop="datePublished">2018-01-17</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/17/面试中常见问题总结/">面试中常见问题总结</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="OC-的动态性"><a href="#OC-的动态性" class="headerlink" title="OC 的动态性"></a>OC 的动态性</h3><p>OC是基于C语言的，C语言在编译阶段就会确定了调用具体的那个函数，OC它的底层是通过runtime 运行时机制来调用函数，在OC中成为消息发送，具体来说就是在编译阶段OC可以调用任何函数，即时这个函数是没有实现的，只有在运行的时候才会根据isa指针和已经注册的方法列表中找到 IMP(函数指针)真正要调用的那个函数，我们平时写的OC代码，在运行的时候也都是转换成了runtime 的方式进行的，不管是什么方法本质都是发送一个消息</p>
<h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><ul>
<li>消息机制原理: 根据方法编号列表 SEL 去映射表中查找对应方法的实现</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Person *p = [Person allo] init];</span><br><span class="line"></span><br><span class="line">// 底层的写法</span><br><span class="line">// alloc</span><br><span class="line">Person *p = objc_msgSend(objc_getClass(&quot;Person&quot;), sel_registerName(&quot;alloc&quot;),);</span><br><span class="line"></span><br><span class="line">// init</span><br><span class="line">p = objc_msgSend(p, sel-registerName(&quot;init&quot;));</span><br><span class="line"></span><br><span class="line">// 调用对象方法本质就是：让对象发消息</span><br><span class="line">objc_msgSend(p, @selector(eat));</span><br><span class="line"></span><br><span class="line">// 调用类方法本质： 让类发消息</span><br><span class="line">objc_msgSend([Person class], @selector(run:), 20);</span><br><span class="line"></span><br><span class="line">// alloc init 也可以理解为：</span><br><span class="line"></span><br><span class="line">id objc = objc_msgSend([NSObject class], @selector(alloc));</span><br><span class="line"></span><br><span class="line">objc = objc_msgSend(objc, @selector(alloc));</span><br></pre></td></tr></table></figure>
<ul>
<li><p>runtime 消息机制调用流程</p>
<p>  每个对象内部都有一个isa指针，指向他自己真实的类来确定调用的是那个类的方法; 每个方法sel都有一个IMP指针（指向现实函数的指针），不管是对象方法还是类方法,都会有一个方法列表</p>
<ol>
<li>发消息时根据对象内部的isa 指针去该类所对应的方法类表中查找方法,如果没有去父类中查找</li>
<li>注册每个方法编号，为了以后快速查找调用</li>
<li>根据方法编号查找对应方法</li>
<li>通过isa指针和IMP指针确定最终调用的函数</li>
</ol>
</li>
<li><p>runtime 常见使用</p>
<ol>
<li>运行是动态添加方法</li>
<li>给分类添加属性，（关联属性）</li>
<li>字典转模型中从先遍历模型属性再从字典中查找相关值实现模型属性赋值</li>
<li>NSCoding 自动归档解档时对象属性过多时 <code>encodeWithCoder:</code> 和 <code>initWithCoder</code> 两个方法实现</li>
</ol>
</li>
</ul>
<h3 id="Runloop"><a href="#Runloop" class="headerlink" title="Runloop"></a>Runloop</h3><ul>
<li><p>概念</p>
<p>NSRunloop 是封装 CFRunloopRef 一套纯<code>C</code>的函数，</p>
</li>
<li><p>作用</p>
<ol>
<li>保持程序持续运行</li>
<li>处理App中各种事件，具体的有：toches事件, NSTimer 事件, Selector 事件, PerformSelector 事件，source 源等等</li>
<li>有事件触发时就运行，没有就休眠</li>
<li>渲染app 中唯一一个主线程上所有UI界面的更新</li>
</ol>
</li>
<li><p>使用和要点</p>
<ol>
<li>Runloop 在程序入口 main 函数中就会开启，并且开启的是主线程不会销毁除非退出程序，保证了程序一直运行并能响应事件和交互</li>
<li>每一条线程都是唯一对应一个Runloop</li>
<li>主线程不需要创建，因为在程序启动的时候就已经创建了，而子线程的需要手动创建 直接获取currentRunloop 方式（本质是使用了懒加载）</li>
<li><p>Runloop 对象是利用字典进行存储，因为一一对应，所有key 和value 就是线程和 他所对应的runloop</p>
</li>
<li><p>Runloop 中 NSDefaultRunLoopMode 一般情况下主线程运行的 Mode</p>
</li>
<li>UIInitializationRunLoopMode 初始化mode,通常不用</li>
<li>UITrackingRunLoopMode 界面跟踪, 用于scrollView 追踪触摸滑动，保证界面不受其他mode影响</li>
<li><p>GSEventReceiveRunLoopMode 用于接收系统事件内部 mode， 通常不用</p>
</li>
<li><p>NSRunLoopCommonModes, 并不是某种具体的 mode ，开发中使用最多，他是一个组合 mode，组合了 NSDefaultRunLoopMode和 NSRunLoopCommonModes</p>
</li>
</ol>
</li>
<li><p>Runloop 相关类</p>
<ol>
<li>Source 事件源/输入源可以理解为 激发源</li>
<li>Timer 基于事件触发，CADisplayLink，NSTimer 都是加到了 Runloop，受 Mode 的影响，GCD 定时器不受Runloop 影响</li>
<li>Observer 相当于runloop 循环中的监听器，时刻监听当前Runloop的运行状态</li>
<li>休眠没事情做的时候可以停下来，处于休眠状态</li>
</ol>
</li>
<li><p>使用场景</p>
<ol>
<li>创建NSTimer</li>
<li>PersforSelector方法</li>
<li>常驻线程：（创建后处于等待状态，有事件时响应事件）<ul>
<li>实现后台收集用户停留时间或者是某个按钮的点击次数，如果使用主线程会不方便，使用runloop解决</li>
</ul>
</li>
<li>AutoreleasePool 自动释放池</li>
<li>UI更新    </li>
</ol>
</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2018/01/17/面试中常见问题总结/" data-id="cjlgmf6o6002dbbfwp66yb6q0" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-iOS即时通讯实现二" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/12/iOS即时通讯实现二/" class="article-date">
  <time datetime="2018-01-12T13:54:26.000Z" itemprop="datePublished">2018-01-12</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/12/iOS即时通讯实现二/">iOS即时通讯实现二</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="实现IM通信所用协议"><a href="#实现IM通信所用协议" class="headerlink" title="实现IM通信所用协议"></a>实现IM通信所用协议</h2><p>几个协议理解</p>
<p>xmpp 是基于xml协议主要是易于扩展，早起用于PC时代的产品使用，流量大，耗电大交互复杂其实并不适合移动互联网时代的IM产品</p>
<p>MQTT 协议 适配多平台，需自己扩展好友，群组等功能</p>
<p>protobut 协议</p>
<h2 id="封装socket，自己实现"><a href="#封装socket，自己实现" class="headerlink" title="封装socket，自己实现"></a>封装socket，自己实现</h2><p>所要考虑的问题</p>
<ul>
<li><p>传输协议选择 </p>
<ul>
<li>TCP ？ 一般公司都选用（技术不是很成熟）</li>
<li>UDP ？QQ 腾讯增加自己的私有协议，保证数据传递的可靠性，解决了丢包，乱序的问题</li>
</ul>
</li>
<li><p>聊天协议选择及代表框架</p>
<ul>
<li>Socket ？ CocoaAsyncSocket </li>
<li>WebSockt ？是传输通讯协议，基于socket封装的一个协议 SocketRocket</li>
<li>MQTT ？MQTTKit 聊天协议为上层协议</li>
<li>protobut 协议 ？</li>
<li>XMPP ？XMPPFramework  聊天协议为上层协议</li>
<li>自定义</li>
</ul>
</li>
<li><p>传输数据格式</p>
<ul>
<li>Json？</li>
<li>XML？</li>
<li>ProtocolBuffer？</li>
</ul>
</li>
<li><p>细节相关</p>
<ul>
<li>TCP 长连接如何保持，</li>
<li>心跳机制</li>
<li>重连机制</li>
<li>数据安全机制</li>
</ul>
</li>
</ul>
<h3 id="CocoaAsyncSocket"><a href="#CocoaAsyncSocket" class="headerlink" title="CocoaAsyncSocket"></a>CocoaAsyncSocket</h3><ul>
<li>CocoaAsyncSocket 的 delegate 用来设置代理处理各个回调</li>
<li>delegateQueue </li>
<li>socketQueue 串行队列，贯穿全类并没有任何加锁，确保了socket 操作中每一步都是线程安全的</li>
<li><p>创建了两个读写队列（本质是数组）</p>
<ul>
<li><code>NSMutableArray *readQueue;</code> </li>
<li><code>NSMutableArray *writeQueue;</code></li>
</ul>
</li>
<li><p>全局数据缓冲: 当前socket未获取完的数据大小</p>
<ul>
<li><code>GCDAsyncSocketPreBuffer *preBuffer;</code></li>
</ul>
</li>
<li><p>交替延时变量: 用于进行另一服务端地址请求的延时 </p>
<ul>
<li><code>alternateAddressDelay</code></li>
</ul>
</li>
<li><p>connect</p>
</li>
<li><p>disconnect</p>
</li>
</ul>
<h2 id="数据粘包-断包"><a href="#数据粘包-断包" class="headerlink" title="数据粘包,断包"></a>数据粘包,断包</h2><ul>
<li><p>粘包: 如果客户端同一时间发送几条数据，而服务器只收到一大条数据</p>
<ul>
<li>原因：</li>
<li><p>由于传输的是数据流，经过TCP传输后，TCP使用了优化算法将多次间隔较小且数据量小的数据合并成一个大的数据块，因此三条数据合并成了一条</p>
<p>  <strong>TCP,UDP都可能造成粘包的原因</strong></p>
</li>
<li><p>发送端需要等缓冲区满了才发送出去，做成粘包</p>
</li>
<li>接收方不及时接收缓冲区的包，造成多个包接收</li>
</ul>
</li>
<li><p>断包: 因为一次发送很大的数据包，缓冲区有限，会分段发送或读取数据</p>
</li>
</ul>
<h2 id="CocoaAsyncSocket的封包，拆包处理"><a href="#CocoaAsyncSocket的封包，拆包处理" class="headerlink" title="CocoaAsyncSocket的封包，拆包处理"></a>CocoaAsyncSocket的封包，拆包处理</h2><ul>
<li><p>读取数据方法：</p>
<pre><code>// 有数据时调用，读取当前消息队列中的未读消息
- (void)readDataWithTimeout:(NSTimeInterval)timeout tag:(long)tag
</code></pre></li>
</ul>
<pre><code>**每次读取数据，每次都必须手动调用上述 readData 方法超时设置为不超时才能触发消息回调的代理**

**因此在第一连接时调用，再在接到消息时调用，上述方法就可以达到每次收到消息都会触发读取消息的代理**

以上做法存在的问题就是没有考虑数据的拆包会有粘包情况，这时候需要用下面两个`read`方法，1. 读取指定长度、2.读取指定边界

    // 读取特定长度数据时调用
    - (void)readDataToLength:(NSUInteger)length withTimeout:(NSTimeInterval)timeout tag:(long)tag

    // 读到特定的 data 边界时调用
    - (void)readDataToData:(NSData *)data withTimeout:(NSTimeInterval)timeout tag:(long)tag


**解决办法及具体思路**

- 封包：给每个数据包增加一个长度或者加一个开始结束标记，表明数据的长度和类型（根据自己的项目：文本、图片、语音、红包、视频、话题、提问等等）
    - 可以在数据包之后加一个结束标识符，解决了传输过程中丢包，丢失头部信息的错误包读取，读到这样的就丢弃直接读下一个数据包

- 拆包：获取每个包的标记，根据标记的数据长度获取数据，最后根据类型处理数据,最后读取数据包头部的边界
</code></pre><ul>
<li><p>利用缓冲区对数据进行读取</p>
<ul>
<li>创建读取数据包</li>
<li>添加到读取的队列中</li>
<li>从队列中取出读取任务包 </li>
<li><p>使用偏移量 <code>maxLength</code> 读取数据 </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">		- (void)readDataWithTimeout:(NSTimeInterval)timeout</span><br><span class="line">                     buffer:(NSMutableData *)buffer</span><br><span class="line">               bufferOffset:(NSUInteger)offset</span><br><span class="line">                  maxLength:(NSUInteger)length</span><br><span class="line">                        tag:(long)tag</span><br><span class="line">&#123;</span><br><span class="line">	if (offset &gt; [buffer length]) &#123;</span><br><span class="line">		LogWarn(@&quot;Cannot read: offset &gt; [buffer length]&quot;);</span><br><span class="line">		return;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	// 1. 创建读取数据包</span><br><span class="line">	GCDAsyncReadPacket *packet = [[GCDAsyncReadPacket alloc] initWithData:buffer</span><br><span class="line">	                                                          startOffset:offset</span><br><span class="line">	                                                            maxLength:length</span><br><span class="line">	                                                              timeout:timeout</span><br><span class="line">	                                                           readLength:0</span><br><span class="line">	                                                           terminator:nil</span><br><span class="line">	                                                                  tag:tag];</span><br><span class="line">	</span><br><span class="line">	dispatch_async(socketQueue, ^&#123; @autoreleasepool &#123;</span><br><span class="line">		</span><br><span class="line">		LogTrace();</span><br><span class="line">		</span><br><span class="line">		if ((flags &amp; kSocketStarted) &amp;&amp; !(flags &amp; kForbidReadsWrites))</span><br><span class="line">		&#123;</span><br><span class="line">			// 2. 向读的队列添加任务包</span><br><span class="line">			[readQueue addObject:packet];</span><br><span class="line">			// 3. 从队列中取出读取任务包 </span><br><span class="line">			[self maybeDequeueRead];</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;&#125;);</span><br><span class="line">	</span><br><span class="line">	// Do not rely on the block being run in order to release the packet,</span><br><span class="line">	// as the queue might get released without the block completing.</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<p>doReadData 方法时读取数据的核心方法</p>
<ul>
<li>如果读取对列中没有数据，就去判是否是上次已经读取了数据，但是因为没有目前还没有读取到数据的标记，这是正好设置了 read 方法中的超时时间，所以要断开socket 连接</li>
</ul>
<p><img src="https://www.jianshu.com/p/fdd3d429bdb3" alt="">                </p>
<ul>
<li>接收到数据后在 socket系统进程的数据缓冲区中<ul>
<li>（基于TLS的分为两种）他们在各自管道中流动，完成数据解密后又流向了全局数据缓冲区<ul>
<li>CFStreem </li>
<li>SSLPrebuffer</li>
</ul>
</li>
</ul>
</li>
</ul>
<p>处理数据逻辑： 如果当前读取包长度给明了，则直接流向currentRead，如果数据长度不清楚，那么则去判断这一次读取的长度，和currentRead可用空间长度去对比，如果长度比currentRead可用空间小，则流向currentRead，否则先用prebuffer来缓冲。</p>
<h3 id="心跳机制"><a href="#心跳机制" class="headerlink" title="心跳机制"></a>心跳机制</h3><ul>
<li>TCP 自带的keep-alive 使用空闲时间来发并且默认超时时间太长是2 小时，</li>
<li>如果应用使用了socks ，socks proxy会让tcp keep-alive失效，因为socks 协议只管转发TCP层具体的数据包，并不会转发TCP协议内的实现具体细节数据包</li>
<li><p>TCP 的长连接理论上是一直保持连接的，可以设置 TCP keep-alive的时间 但是实际情况下中，可能出现故障或者是因为防火墙的原因会自动把一定时间段内没有数据交互的连接给断开，心跳机制就可以维持长连接，保持活跃状态</p>
</li>
<li><p>iOS 中使用 NSTimer  <code>scheduledTimerWithTimeInterval</code> 需要在调用之前的关键位置设置 fireDate 为未来的某个时间, 然后再需要的时候开启</p>
</li>
<li>或者直接使用 <code>timerWithTimeInterval</code> 创建，然后添加到<code>runloop</code>中</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2018/01/12/iOS即时通讯实现二/" data-id="cjlgmf6nu001sbbfwhi1s8azp" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  
    <article id="post-知识归纳总结" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2018/01/10/知识归纳总结/" class="article-date">
  <time datetime="2018-01-10T15:26:18.000Z" itemprop="datePublished">2018-01-10</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2018/01/10/知识归纳总结/">iOS 即使通讯网络知识篇</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="网络七层协议"><a href="#网络七层协议" class="headerlink" title="网络七层协议"></a>网络七层协议</h2><p>读《图解TCP/IP》第5版以及看过的关于网络文章之后自己的理解</p>
<p>OSI (Open System Interconnec) 译为 开发式系统互联 七层模型从下到上一次是：物理层 -&gt; 数据链路层 —&gt; 网络层 -&gt; 传输层 -&gt; 会话层 -&gt; 表示层 -》 应用层</p>
<p>数据每次经过一层之后就会在数据头部增加一个首部信息</p>
<h5 id="物理层：网卡-网线-集线器-中继器-调制解调器"><a href="#物理层：网卡-网线-集线器-中继器-调制解调器" class="headerlink" title="物理层：网卡,网线,集线器,中继器,调制解调器"></a>物理层：网卡,网线,集线器,中继器,调制解调器</h5><ul>
<li>定义设备标准，如网线，光纤接口类型，将0和1转化为电信号的强和弱，达到传输<strong>比特流</strong>目的，这层数据叫比特</li>
</ul>
<h5 id="数据链路层：网桥-交换机"><a href="#数据链路层：网桥-交换机" class="headerlink" title="数据链路层：网桥,交换机"></a>数据链路层：网桥,交换机</h5><ul>
<li>传输的地址帧，并且有检测错误功能，保证数据可靠传输， 这层数据叫帧</li>
</ul>
<h5 id="网络层：路由器"><a href="#网络层：路由器" class="headerlink" title="网络层：路由器"></a>网络层：路由器</h5><ul>
<li>两个计算机通信时可能会经过多个数据链路或者通信子网，网络层将数据链路层的帧组成数据包，包中有封装好的包头，其中含有逻辑地址信息（源站点和目的站点），此层为数据包选择合适的路由和交换结点,IP协议产生，这层数据叫着数据包</li>
</ul>
<h5 id="传输层："><a href="#传输层：" class="headerlink" title="传输层："></a>传输层：</h5><ul>
<li>解决数据如何在网络中传输，这个层负责获取全部信息，因此，它必须跟踪数据单元碎片、乱序到达的 数据包和其它在传输过程中可能发生的危险。第4层为上层提供端到端（最终用户到最终用户）的透明的、可靠的数据传输服务。所为透明的传输是指在通信过程中 传输层对上层屏蔽了通信传输系统的具体细节。传输层协议的代表包括：TCP、UDP、SPX等</li>
</ul>
<h5 id="会话层："><a href="#会话层：" class="headerlink" title="会话层："></a>会话层：</h5><ul>
<li>这一层也可以称为会晤层或对话层，在会话层及以上的高层次中，数据传送的单位不再另外命名，而是统称为报文。会话层不参与具体的传输，它提供包括访问验证和会话管理在内的建立和维护应用之间通信的机制。如服务器验证用户登录便是由会话层完成的</li>
</ul>
<h5 id="表示层："><a href="#表示层：" class="headerlink" title="表示层："></a>表示层：</h5><ul>
<li>这一层主要解决拥护信息的语法表示问题。它将欲交换的数据从适合于某一用户的抽象语法，转换为适合于OSI系统内部使用的传送语法。即提供格式化的表示和转换数据服务。数据的压缩和解压缩， 加密和解密等工作都由表示层负责。</li>
</ul>
<h5 id="应用层：HTTP-协议"><a href="#应用层：HTTP-协议" class="headerlink" title="应用层：HTTP 协议"></a>应用层：HTTP 协议</h5><ul>
<li>如何包装数据</li>
</ul>
<p><strong>通常从上到下会分成四层</strong></p>
<p>TCP/IP 通常是指TCP/IP协议族,是一组不同协议组合在一起构成的协议族</p>
<ul>
<li>应用层：FTP 应用层协议</li>
<li>传输层：TCP,UDP 传输层协议,TCP 提供了一个可靠的服务</li>
<li>网络层：IP,ICMP 网络层协议，传输时不可靠的</li>
<li>链路层：以太网协议</li>
</ul>
<h2 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h2><p><strong>为了解决不同计算机上进程间通信问题</strong><br>服务器在指定的端口上监听，然后生成一对儿新的socket 进行通讯，一个线程对应一个socket</p>
<p>英文翻译为“插座”通常称为”套接字”, 本质是对于TCP/IP的封装，有客户端 socket 和 服务端socket </p>
<ul>
<li>流式 Socket (STREAM): 是一种面向连接的socket，针对于面向连接的TCP服务应用，因为安全所以效率低</li>
<li>数据报式Socket (DATAGRAM): 是一种无连接的SOcket，正对于无连接的UDP服务应用，无序，不安全，需要在接收端分析重排或者要求重发，所以效率高</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://github.com/aTreey/2018/01/10/知识归纳总结/" data-id="cjlgmf6o5002bbbfwsz46zlhp" class="article-share-link">Teilen</a>
      
      
    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/">&laquo; zurück</a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="page-number" href="/page/4/">4</a><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/3/">weiter &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AES-Base64-MD5/">AES, Base64, MD5</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Alamofire/">Alamofire</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/AlertView/">AlertView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/GCD/">GCD</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Hexo/">Hexo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/OC-JS/">OC, JS</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quartz-2D/">Quartz 2D</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Quartz2D/">Quartz2D</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/RunTime/">RunTime</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SDWebImage/">SDWebImage</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/SQL/">SQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Swift/">Swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/TableView/">TableView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/WKWebView/">WKWebView</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/git/">git</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/swift/">swift</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/异步/">异步</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/本地缓存/">本地缓存</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AES-Base64-MD5/" style="font-size: 10px;">AES, Base64, MD5</a> <a href="/tags/Alamofire/" style="font-size: 10px;">Alamofire</a> <a href="/tags/AlertView/" style="font-size: 10px;">AlertView</a> <a href="/tags/GCD/" style="font-size: 10px;">GCD</a> <a href="/tags/Hexo/" style="font-size: 10px;">Hexo</a> <a href="/tags/OC-JS/" style="font-size: 10px;">OC, JS</a> <a href="/tags/Quartz-2D/" style="font-size: 10px;">Quartz 2D</a> <a href="/tags/Quartz2D/" style="font-size: 15px;">Quartz2D</a> <a href="/tags/RunTime/" style="font-size: 10px;">RunTime</a> <a href="/tags/SDWebImage/" style="font-size: 10px;">SDWebImage</a> <a href="/tags/SQL/" style="font-size: 10px;">SQL</a> <a href="/tags/Swift/" style="font-size: 10px;">Swift</a> <a href="/tags/TableView/" style="font-size: 10px;">TableView</a> <a href="/tags/WKWebView/" style="font-size: 20px;">WKWebView</a> <a href="/tags/git/" style="font-size: 10px;">git</a> <a href="/tags/swift/" style="font-size: 15px;">swift</a> <a href="/tags/异步/" style="font-size: 10px;">异步</a> <a href="/tags/本地缓存/" style="font-size: 10px;">本地缓存</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archiv</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/08/">August 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/07/">July 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/06/">June 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/03/">March 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/02/">February 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2018/01/">January 2018</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/12/">December 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/11/">November 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/04/">April 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/03/">March 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/02/">February 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2017/01/">January 2017</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/12/">December 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/11/">November 2016</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/10/">October 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">letzter Beitrag</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2018/08/30/Swift错误处理/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/08/25/Swift协议别名/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/08/25/Swift协议扩展/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/08/25/Swift下标和运算符重载/">(no title)</a>
          </li>
        
          <li>
            <a href="/2018/08/22/iOS通过URL获取HTML中标题/">(no title)</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2018 aTreey<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>